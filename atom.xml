<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>running-in-sky</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-10-29T17:40:48.750Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>zzzhy</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>nginx编译参数</title>
    <link href="http://yoursite.com/2019/10/30/nginx-compile-opts/"/>
    <id>http://yoursite.com/2019/10/30/nginx-compile-opts/</id>
    <published>2019-10-29T17:39:52.000Z</published>
    <updated>2019-10-29T17:40:48.750Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># nginx参数：</span></span><br><span class="line">–prefix= 指向安装目录</span><br><span class="line">–sbin-path 指向（执行）程序文件（nginx）</span><br><span class="line">–conf-path= 指向配置文件（nginx.conf）</span><br><span class="line">–error-log-path= 指向错误日志目录</span><br><span class="line">–pid-path= 指向pid文件（nginx.pid）</span><br><span class="line">–lock-path= 指向lock文件（nginx.lock）（安装文件锁定，防止安装文件被别人利用，或自己误操作。）</span><br><span class="line">–user= 指定程序运行时的非特权用户</span><br><span class="line">–group= 指定程序运行时的非特权用户组</span><br><span class="line">–builddir= 指向编译目录</span><br><span class="line">–with-rtsig_module 启用rtsig模块支持（实时信号）</span><br><span class="line">–with-select_module 启用select模块支持（一种轮询模式,不推荐在高载环境下使用）禁用：–without-select_module</span><br><span class="line">–with-poll_module 启用poll模块支持（功能与select相同，与select特性相同，为一种轮询模式,不推荐在高载环境下使用）</span><br><span class="line">–with-file-aio 启用file aio支持（一种APL文件传输格式）</span><br><span class="line">–with-ipv6 启用ipv6支持</span><br><span class="line">–with-http_ssl_module 启用ngx_http_ssl_module支持（使支持https请求，需已安装openssl）</span><br><span class="line">–with-http_realip_module 启用ngx_http_realip_module支持（这个模块允许从请求标头更改客户端的IP地址值，默认为关）</span><br><span class="line">–with-http_addition_module 启用ngx_http_addition_module支持（作为一个输出过滤器，支持不完全缓冲，分部分响应请求）</span><br><span class="line">–with-http_xslt_module 启用ngx_http_xslt_module支持（过滤转换XML请求）</span><br><span class="line">–with-http_image_filter_module 启用ngx_http_image_filter_module支持（传输JPEG/GIF/PNG 图片的一个过滤器）（默认为不启用。gd库要用到）</span><br><span class="line">–with-http_geoip_module 启用ngx_http_geoip_module支持（该模块创建基于与MaxMind GeoIP二进制文件相配的客户端IP地址的ngx_http_geoip_module变量）</span><br><span class="line">–with-http_sub_module 启用ngx_http_sub_module支持（允许用一些其他文本替换nginx响应中的一些文本）</span><br><span class="line">–with-http_dav_module 启用ngx_http_dav_module支持（增加PUT,DELETE,MKCOL：创建集合,COPY和MOVE方法）默认情况下为关闭，需编译开启</span><br><span class="line">–with-http_flv_module 启用ngx_http_flv_module支持（提供寻求内存使用基于时间的偏移量文件）</span><br><span class="line">–with-http_gzip_static_module 启用ngx_http_gzip_static_module支持（在线实时压缩输出数据流）</span><br><span class="line">–with-http_random_index_module 启用ngx_http_random_index_module支持（从目录中随机挑选一个目录索引）</span><br><span class="line">–with-http_secure_link_module 启用ngx_http_secure_link_module支持（计算和检查要求所需的安全链接网址）</span><br><span class="line">–with-http_degradation_module  启用ngx_http_degradation_module支持（允许在内存不足的情况下返回204或444码）</span><br><span class="line">–with-http_stub_status_module 启用ngx_http_stub_status_module支持（获取nginx自上次启动以来的工作状态）</span><br><span class="line">–without-http_charset_module 禁用ngx_http_charset_module支持（重新编码web页面，但只能是一个方向–服务器端到客户端，并且只有一个字节的编码可以被重新编码）</span><br><span class="line">–without-http_gzip_module 禁用ngx_http_gzip_module支持（该模块同-with-http_gzip_static_module功能一样）</span><br><span class="line">–without-http_ssi_module 禁用ngx_http_ssi_module支持（该模块提供了一个在输入端处理处理服务器包含文件（SSI）的过滤器，目前支持SSI命令的列表是不完整的）</span><br><span class="line">–without-http_userid_module 禁用ngx_http_userid_module支持（该模块用来处理用来确定客户端后续请求的cookies）</span><br><span class="line">–without-http_access_module 禁用ngx_http_access_module支持（该模块提供了一个简单的基于主机的访问控制。允许/拒绝基于ip地址）</span><br><span class="line">–without-http_auth_basic_module禁用ngx_http_auth_basic_module（该模块是可以使用用户名和密码基于http基本认证方法来保护你的站点或其部分内容）</span><br><span class="line">–without-http_autoindex_module 禁用<span class="built_in">disable</span> ngx_http_autoindex_module支持（该模块用于自动生成目录列表，只在ngx_http_index_module模块未找到索引文件时发出请求。）</span><br><span class="line">–without-http_geo_module 禁用ngx_http_geo_module支持（创建一些变量，其值依赖于客户端的IP地址）</span><br><span class="line">–without-http_map_module 禁用ngx_http_map_module支持（使用任意的键/值对设置配置变量）</span><br><span class="line">–without-http_split_clients_module 禁用ngx_http_split_clients_module支持（该模块用来基于某些条件划分用户。条件如：ip地址、报头、cookies等等）</span><br><span class="line">–without-http_referer_module 禁用<span class="built_in">disable</span> ngx_http_referer_module支持（该模块用来过滤请求，拒绝报头中Referer值不正确的请求）</span><br><span class="line">–without-http_rewrite_module 禁用ngx_http_rewrite_module支持（该模块允许使用正则表达式改变URI，并且根据变量来转向以及选择配置。如果在server级别设置该选项，那么他们将在 location之前生效。如果在location还有更进一步的重写规则，location部分的规则依然会被执行。如果这个URI重写是因为location部分的规则造成的，那么 location部分会再次被执行作为新的URI。 这个循环会执行10次，然后Nginx会返回一个500错误。）</span><br><span class="line">–without-http_proxy_module 禁用ngx_http_proxy_module支持（有关代理服务器）</span><br><span class="line">–without-http_fastcgi_module 禁用ngx_http_fastcgi_module支持（该模块允许Nginx 与FastCGI 进程交互，并通过传递参数来控制FastCGI 进程工作。 ）FastCGI一个常驻型的公共网关接口。</span><br><span class="line">–without-http_uwsgi_module 禁用ngx_http_uwsgi_module支持（该模块用来医用uwsgi协议，uWSGI服务器相关）</span><br><span class="line">–without-http_scgi_module 禁用ngx_http_scgi_module支持（该模块用来启用SCGI协议支持，SCGI协议是CGI协议的替代。它是一种应用程序与HTTP服务接口标准。它有些像FastCGI但他的设计 更容易实现。）</span><br><span class="line">–without-http_memcached_module 禁用ngx_http_memcached_module支持（该模块用来提供简单的缓存，以提高系统效率）</span><br><span class="line">-without-http_limit_zone_module 禁用ngx_http_limit_zone_module支持（该模块可以针对条件，进行会话的并发连接数控制）</span><br><span class="line">–without-http_limit_req_module 禁用ngx_http_limit_req_module支持（该模块允许你对于一个地址进行请求数量的限制用一个给定的session或一个特定的事件）</span><br><span class="line">–without-http_empty_gif_module 禁用ngx_http_empty_gif_module支持（该模块在内存中常驻了一个1*1的透明GIF图像，可以被非常快速的调用）</span><br><span class="line">–without-http_browser_module 禁用ngx_http_browser_module支持（该模块用来创建依赖于请求报头的值。如果浏览器为modern ，则<span class="variable">$modern_browser</span>等于modern_browser_value指令分配的值；如 果浏览器为old，则<span class="variable">$ancient_browser</span>等于 ancient_browser_value指令分配的值；如果浏览器为 MSIE中的任意版本，则 <span class="variable">$msie</span>等于1）</span><br><span class="line">–without-http_upstream_ip_hash_module 禁用ngx_http_upstream_ip_hash_module支持（该模块用于简单的负载均衡）</span><br><span class="line">–with-http_perl_module 启用ngx_http_perl_module支持（该模块使nginx可以直接使用perl或通过ssi调用perl）</span><br><span class="line">–with-perl_modules_path= 设定perl模块路径</span><br><span class="line">–with-perl= 设定perl库文件路径</span><br><span class="line">–http-log-path= 设定access <span class="built_in">log</span>路径</span><br><span class="line">–http-client-body-temp-path= 设定http客户端请求临时文件路径</span><br><span class="line">–http-proxy-temp-path= 设定http代理临时文件路径</span><br><span class="line">–http-fastcgi-temp-path= 设定http fastcgi临时文件路径</span><br><span class="line">–http-uwsgi-temp-path= 设定http uwsgi临时文件路径</span><br><span class="line">–http-scgi-temp-path= 设定http scgi临时文件路径</span><br><span class="line">-without-http 禁用http server功能</span><br><span class="line">–without-http-cache 禁用http cache功能</span><br><span class="line">–with-mail 启用POP3/IMAP4/SMTP代理模块支持</span><br><span class="line">–with-mail_ssl_module 启用ngx_mail_ssl_module支持</span><br><span class="line">–without-mail_pop3_module 禁用pop3协议（POP3即邮局协议的第3个版本,它是规定个人计算机如何连接到互联网上的邮件服务器进行收发邮件的协议。是因特网电子邮件的第一个离线协议标 准,POP3协议允许用户从服务器上把邮件存储到本地主机上,同时根据客户端的操作删除或保存在邮件服务器上的邮件。POP3协议是TCP/IP协议族中的一员，主要用于 支持使用客户端远程管理在服务器上的电子邮件）</span><br><span class="line">–without-mail_imap_module 禁用imap协议（一种邮件获取协议。它的主要作用是邮件客户端可以通过这种协议从邮件服务器上获取邮件的信息，下载邮件等。IMAP协议运行在TCP/IP协议之上， 使用的端口是143。它与POP3协议的主要区别是用户可以不用把所有的邮件全部下载，可以通过客户端直接对服务器上的邮件进行操作。）</span><br><span class="line">–without-mail_smtp_module 禁用smtp协议（SMTP即简单邮件传输协议,它是一组用于由源地址到目的地址传送邮件的规则，由它来控制信件的中转方式。SMTP协议属于TCP/IP协议族，它帮助每台计算机在发送或中转信件时找到下一个目的地。）</span><br><span class="line">–with-google_perftools_module 启用ngx_google_perftools_module支持（调试用，剖析程序性能瓶颈）</span><br><span class="line">–with-cpp_test_module 启用ngx_cpp_test_module支持</span><br><span class="line">–add-module= 启用外部模块支持</span><br><span class="line">–with-cc= 指向C编译器路径</span><br><span class="line">–with-cpp= 指向C预处理路径</span><br><span class="line">–with-cc-opt= 设置C编译器参数（PCRE库，需要指定–with-cc-opt=”-I /usr/<span class="built_in">local</span>/include”，如果使用select()函数则需要同时增加文件描述符数量，可以通过–with-cc- opt=”-D FD_SETSIZE=2048”指定。）</span><br><span class="line">–with-ld-opt= 设置连接文件参数。（PCRE库，需要指定–with-ld-opt=”-L /usr/<span class="built_in">local</span>/lib”。）</span><br><span class="line">–with-cpu-opt= 指定编译的CPU，可用的值为: pentium, pentiumpro, pentium3, pentium4, athlon, opteron, amd64, sparc32, sparc64, ppc64</span><br><span class="line">–without-pcre 禁用pcre库</span><br><span class="line">–with-pcre 启用pcre库</span><br><span class="line">–with-pcre= 指向pcre库文件目录</span><br><span class="line">–with-pcre-opt= 在编译时为pcre库设置附加参数</span><br><span class="line">–with-md5= 指向md5库文件目录（消息摘要算法第五版，用以提供消息的完整性保护）</span><br><span class="line">–with-md5-opt= 在编译时为md5库设置附加参数</span><br><span class="line">–with-md5-asm 使用md5汇编源</span><br><span class="line">–with-sha1= 指向sha1库目录（数字签名算法，主要用于数字签名）</span><br><span class="line">–with-sha1-opt= 在编译时为sha1库设置附加参数</span><br><span class="line">–with-sha1-asm 使用sha1汇编源</span><br><span class="line">–with-zlib= 指向zlib库目录</span><br><span class="line">–with-zlib-opt= 在编译时为zlib设置附加参数</span><br><span class="line">–with-zlib-asm= 为指定的CPU使用zlib汇编源进行优化，CPU类型为pentium, pentiumpro</span><br><span class="line">–with-libatomic 为原子内存的更新操作的实现提供一个架构</span><br><span class="line">–with-libatomic= 指向libatomic_ops安装目录</span><br><span class="line">–with-openssl= 指向openssl安装目录</span><br><span class="line">–with-openssl-opt 在编译时为openssl设置附加参数</span><br><span class="line">–with-debug 启用debug日志</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=
      
    
    </summary>
    
    
      <category term="nginx" scheme="http://yoursite.com/categories/nginx/"/>
    
    
      <category term="nginx" scheme="http://yoursite.com/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>sql tuning</title>
    <link href="http://yoursite.com/2019/10/30/sql-tuning/"/>
    <id>http://yoursite.com/2019/10/30/sql-tuning/</id>
    <published>2019-10-29T17:20:51.000Z</published>
    <updated>2019-10-29T17:48:13.973Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><ol><li>对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。</li><li>应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，<br>Sql 代码 : select id from t where num is null;<br>可以在 num 上设置默认值 0,确保表中 num 列没有 null 值，然后这样查询：<br>Sql 代码 : select id from t where num=0;</li><li>应尽量避免在 where 子句中使用!=或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描。</li><li>应尽量避免在 where 子句中使用 or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，<br>Sql 代码 : select id from t where num=10 or num=20;<br>可以这样查询：<br>Sql 代码 : select id from t where num=10 union all select id from t where num=20;</li><li>in 和 not in 也要慎用，否则会导致全表扫描，如：<br>Sql 代码 : select id from t where num in(1,2,3);<br>对于连续的数值，能用 between 就不要用 in 了：<br>Sql 代码 : select id from t where num between 1 and 3;</li><li>下面的查询也将导致全表扫描：<br>Sql 代码 : select id from t where name like ‘%c%’;<br>若要提高效率，可以考虑全文检索。</li><li>如果在 where 子句中使用参数，也会导致全表扫描。因为 SQL 只有在运行时才会解析局部变量，但优 化程序不能将访问计划的选择推迟到运行时;它必须在编译时进行选择。然 而，如果在编译时建立访问计 划，变量的值还是未知的，因而无法作为索引选择的输入项。如下面语句将进行全表扫描：<br>Sql 代码 : select id from t where num=@num ;<br>可以改为强制查询使用索引：<br>Sql 代码 : select id from t with(index(索引名)) where num=@num ;</li><li>应尽量避免在 where 子句中对字段进行表达式操作， 这将导致引擎放弃使用索引而进行全表扫描。<br>Sql 代码 : select id from t where num/2=100;<br>可以这样查询：<br>Sql 代码 : select id from t where num=100*2;</li><li>应尽量避免在 where 子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。如：<br>Sql 代码 : select id from t where substring(name,1,3)=’abc’;#name 以 abc 开头的 id<br>应改为：<br>Sql 代码 : select id from t where name like ‘abc%’;</li><li>不要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用 索引。</li><li>在使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索引中的第一个字段作为条件 时才能保证系统使用该索引， 否则该索引将不会 被使用， 并且应尽可能的让字段顺序与索引顺序相一致。</li><li>不要写一些没有意义的查询，如需要生成一个空表结构：<br>Sql 代码 : select col1,col2 into #t from t where 1=0;<br>这类代码不会返回任何结果集，但是会消耗系统资源的，应改成这样：<br>Sql 代码 : create table #t(…);</li><li>很多时候用 exists 代替 in 是一个好的选择：<br>Sql 代码 : select num from a where num in(select num from b);<br>用下面的语句替换：<br>Sql 代码 : select num from a where exists(select 1 from b where num=a.num);</li><li>并不是所有索引对查询都有效，SQL 是根据表中数据来进行查询优化的，当索引列有大量数据重复时， SQL 查询可能不会去利用索引，如一表中有字段 <strong>*,male、female 几乎各一半，那么即使在 *</strong> 上建 了索引也对查询效率起不了作用。</li><li>索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。一个表的索引数最好不要超过 6 个，若太多则应考虑一些不常使用到的列上建的索引是否有必要。</li><li>应尽可能的避免更新 clustered 索引数据列， 因为 clustered 索引数据列的顺序就是表记录的物理存储顺序，一旦该列值改变将导致整个表记录的顺序的调整，会耗费相当大的资源。若应用系统需要频繁更新 clustered 索引数据列，那么需要考虑是否应将该索引建为 clustered 索引。</li><li>尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并 会增加存储开销。这是因为引擎在处理查询和连接时会逐个比较字符串中每一个字符，而对于数字型而言 只需要比较一次就够了。</li><li>尽可能的使用 varchar/nvarchar 代替 char/nchar , 因为首先变长字段存储空间小， 可以节省存储空间， 其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。</li><li>任何地方都不要使用 select * from t ,用具体的字段列表代替“*”,不要返回用不到的任何字段。</li><li>尽量使用表变量来代替临时表。如果表变量包含大量数据，请注意索引非常有限(只有主键索引)。</li><li>避免频繁创建和删除临时表，以减少系统表资源的消耗。</li><li>临时表并不是不可使用，适当地使用它们可以使某些例程更有效，例如，当需要重复引用大型表或常用 表中的某个数据集时。但是，对于一次性事件， 最好使用导出表。</li><li>在新建临时表时，如果一次性插入数据量很大，那么可以使用 select into 代替 create table,避免造成大量 log ,以提高速度;如果数据量不大，为了缓和系统表的资源，应先 create table,然后 insert.</li><li>如果使用到了临时表， 在存储过程的最后务必将所有的临时表显式删除， 先 truncate table ,然后 drop table ,这样可以避免系统表的较长时间锁定。</li><li>尽量避免使用游标，因为游标的效率较差，如果游标操作的数据超过 1 万行，那么就应该考虑改写。</li><li>使用基于游标的方法或临时表方法之前，应先寻找基于集的解决方案来解决问题，基于集的方法通常更 有效。</li><li>与临时表一样，游标并不是不可使用。对小型数据集使用 FAST_FORWARD 游标通常要优于其他逐行处理方法，尤其是在必须引用几个表才能获得所需的数据时。在结果集中包括“合计”的例程通常要比使用游标执行的速度快。如果开发时间允许，基于游标的方法和基于集的方法都可以尝试一下，看哪一种方法的效果更好。</li><li>在所有的存储过程和触发器的开始处设置 SET NOCOUNT ON ,在结束时设置 SET NOCOUNT OFF .无需在执行存储过程和触发器的每个语句后向客户端发送 DONE_IN_PROC 消息。</li><li>尽量避免大事务操作，提高系统并发能力。 sql 优化方法使用索引来更快地遍历表。 缺省情况下建立的索引是非群集索引，但有时它并不是最佳的。在非群集索引下，数据在物理上随机存放在数据页上。合理的索引设计要建立在对各种查询的分析和预测上。一般来说：<br>a.有大量重复值、且经常有范围查询( &gt; ,&lt; ,&gt; =,&lt; =)和 order by、group by 发生的列，可考虑建立集群索引;<br>b.经常同时存取多列，且每列都含有重复值可考虑建立组合索引;<br>c.组合索引要尽量使关键查询形成索引覆盖，其前导列一定是使用最频繁的列。索引虽有助于提高性能但 不是索引越多越好，恰好相反过多的索引会导致系统低效。用户在表中每加进一个索引，维护索引集合就 要做相应的更新工作。</li><li>定期分析表和检查表。<br>分析表的语法：ANALYZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tb1_name[, tbl_name]…<br>以上语句用于分析和存储表的关键字分布，分析的结果将可以使得系统得到准确的统计信息，使得SQL能够生成正确的执行计划。如果用户感觉实际执行计划并不是预期的执行计划，执行一次分析表可能会解决问题。在分析期间，使用一个读取锁定对表进行锁定。这对于MyISAM，DBD和InnoDB表有作用。<br>例如分析一个数据表：analyze table table_name<br>检查表的语法：CHECK TABLE tb1_name[,tbl_name]…[option]…option = {QUICK | FAST | MEDIUM | EXTENDED | CHANGED}<br>检查表的作用是检查一个或多个表是否有错误，CHECK TABLE 对MyISAM 和 InnoDB表有作用，对于MyISAM表，关键字统计数据被更新<br>CHECK TABLE 也可以检查视图是否有错误，比如在视图定义中被引用的表不存在。</li><li>定期优化表。<br>优化表的语法：OPTIMIZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tb1_name [,tbl_name]…<br>如果删除了表的一大部分，或者如果已经对含有可变长度行的表(含有 VARCHAR、BLOB或TEXT列的表)进行更多更改，则应使用OPTIMIZE TABLE命令来进行表优化。这个命令可以将表中的空间碎片进行合并，并且可以消除由于删除或者更新造成的空间浪费，但OPTIMIZE TABLE 命令只对MyISAM、 BDB 和InnoDB表起作用。<br>例如： optimize table table_name<br>注意： analyze、check、optimize执行期间将对表进行锁定，因此一定注意要在MySQL数据库不繁忙的时候执行相关的操作。</li></ol><h3 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h3><ol><li>在海量查询时尽量少用格式转换。</li><li>ORDER BY 和 GROPU BY:使用 ORDER BY 和 GROUP BY 短语，任何一种索引都有助于 SELECT 的性能提高。</li><li>任何对列的操作都将导致表扫描，它包括数据库教程函数、计算表达式等等，查询时要尽可能将操作移 至等号右边。</li><li>IN、OR 子句常会使用工作表，使索引失效。如果不产生大量重复值，可以考虑把子句拆开。拆开的子 句中应该包含索引。</li><li>只要能满足你的需求，应尽可能使用更小的数据类型：例如使用 MEDIUMINT 代替 INT</li><li>尽量把所有的列设置为 NOT NULL,如果你要保存 NULL,手动去设置它，而不是把它设为默认值。</li><li>尽量少用 VARCHAR、TEXT、BLOB 类型</li><li>如果你的数据只有你所知的少量的几个。最好使用 ENUM 类型</li><li>正如 graymice 所讲的那样，建立索引。</li><li>合理用运分表与分区表提高数据存放和提取速度。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;基础&quot;&gt;&lt;a href=&quot;#基础&quot; class=&quot;headerlink&quot; title=&quot;基础&quot;&gt;&lt;/a&gt;基础&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。&lt;/li&gt;
&lt;li&gt;应尽
      
    
    </summary>
    
    
      <category term="sql" scheme="http://yoursite.com/categories/sql/"/>
    
    
      <category term="tuning" scheme="http://yoursite.com/tags/tuning/"/>
    
      <category term="sql" scheme="http://yoursite.com/tags/sql/"/>
    
  </entry>
  
  <entry>
    <title>akka best practice</title>
    <link href="http://yoursite.com/2019/10/30/akka-best-practice/"/>
    <id>http://yoursite.com/2019/10/30/akka-best-practice/</id>
    <published>2019-10-29T17:12:36.000Z</published>
    <updated>2019-10-29T17:22:33.403Z</updated>
    
    <content type="html"><![CDATA[<ul><li>使用tell而非ask，ExtraActor模式</li><li>使用dispatcher隔离耗时阻塞任务，区分不同的任务类别使用不同线程数量的线程池</li><li>一般来说ForkJoinPool的效率最高</li><li>使用router来进行多核编程，BalancePool适用于本地，所有actor共用一个邮箱</li><li>包含状态的可以使用become/unbecome来进行编程，使状态清晰，代码逻辑结构简单</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;使用tell而非ask，ExtraActor模式&lt;/li&gt;
&lt;li&gt;使用dispatcher隔离耗时阻塞任务，区分不同的任务类别使用不同线程数量的线程池&lt;/li&gt;
&lt;li&gt;一般来说ForkJoinPool的效率最高&lt;/li&gt;
&lt;li&gt;使用router来进行多核编
      
    
    </summary>
    
    
      <category term="akka" scheme="http://yoursite.com/categories/akka/"/>
    
    
      <category term="akka" scheme="http://yoursite.com/tags/akka/"/>
    
      <category term="actor" scheme="http://yoursite.com/tags/actor/"/>
    
      <category term="tuning" scheme="http://yoursite.com/tags/tuning/"/>
    
  </entry>
  
  <entry>
    <title>spark streaming入门</title>
    <link href="http://yoursite.com/2019/10/30/spark-streaming-indoor/"/>
    <id>http://yoursite.com/2019/10/30/spark-streaming-indoor/</id>
    <published>2019-10-29T16:31:45.000Z</published>
    <updated>2019-10-29T17:47:23.488Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 构建一个 Spark Streaming 应用程序的4 个步骤</span></span><br><span class="line">scala&gt; val ssc = new StreamingContext(sc,Seconds(5))</span><br><span class="line"></span><br><span class="line">scala&gt; val lines = ssc.socketTextStream(<span class="string">"localhost"</span>,9999)</span><br><span class="line"></span><br><span class="line">scala&gt; val words = lines.flatMap(_.split(<span class="string">" "</span>))</span><br><span class="line"></span><br><span class="line">scala&gt; val pairs = words.map(word =&gt; (word,1))</span><br><span class="line"></span><br><span class="line">scala&gt; val wordCounts = pairs.reduceByKey(_+_)</span><br><span class="line"></span><br><span class="line">scala&gt; wordCounts.print()</span><br><span class="line"></span><br><span class="line">scala&gt; ssc.start()</span><br></pre></td></tr></table></figure><h2 id="1、构建-Streaming-Context-对象"><a href="#1、构建-Streaming-Context-对象" class="headerlink" title="1、构建 Streaming Context 对象"></a>1、构建 Streaming Context 对象</h2><blockquote><p>使用 Spark Streaming 需要创建 StreamingContext 对象。Spark Streaming 需要制定处理数据的时间间隔，如 1s，那么 Spark Streaming 会以1s为时间窗口进行数据处理。此参数需要根据用户的需求和集群的处理能力进行适当的设置，它的生命周期会伴随整个StreamingContext 的生命周期且无法重新设置。因此，用户需要从需求和集群处理能力出发，设置一个合理的时间间隔。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SparkConf sparkConf = <span class="keyword">new</span> SparkConf().setAppName(<span class="string">"JavaRecoverableNetworkWordCount"</span>);</span><br><span class="line"> <span class="comment">// Create the context with a 1 second batch size</span></span><br><span class="line"> <span class="comment">//首先通过 JavaStreamingContextFactory 创建 Spark Streaming 过程。</span></span><br><span class="line"> JavaStreamingContext ssc = <span class="keyword">new</span> JavaStreamingContext(sparkConf, Durations.seconds(<span class="number">1</span>));</span><br><span class="line"> ssc.checkpoint(checkpointDirectory);</span><br></pre></td></tr></table></figure><blockquote><p>Spark Streaming 有特定的窗口操作，窗口操作涉及两个参数：一个是滑动窗口的宽度（Window Duration）；另一个是窗口滑动的频率（Slide Duration），这两个参数必须是 batch size 的倍数。例如以过去 5 秒钟为一个输入窗口，每 1 秒统计一下 WordCount，那么我们会将过去 5 秒钟的每一秒钟的 WordCount 都进行统计，然后进行叠加，得出这个窗口中的单词统计。</p></blockquote><h2 id="2、创建-InputDStream"><a href="#2、创建-InputDStream" class="headerlink" title="2、创建 InputDStream"></a>2、创建 InputDStream</h2><blockquote><p>如同 Strom 的 Spout 一样，Spark Streaming 需要指明数据源。例如 socketTextStream，Spark Streaming 将以套接字连接作为数据源读取数据。当然，Spark Streaming 支持多种不同的数据源，包括 kafkaStream、flumeStream、fileStream、networkStream 等。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JavaReceiverInputDStream&lt;<span class="built_in">String</span>&gt; lines = ssc.socketTextStream(ip, port);</span><br></pre></td></tr></table></figure><h2 id="3、操作-DStream"><a href="#3、操作-DStream" class="headerlink" title="3、操作 DStream"></a>3、操作 DStream</h2><blockquote><p>对于从数据源得到的DStream，用户可以在其基础上进行各种操作，如 WordCount 的操作就是一个典型的单词计数执行流程，即对当前时间窗口内从数据源得到的数据进行分词，然后利用 MapReduce 算法映射和计算，最后使用 print() 输出结果。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">JavaDStream&lt;<span class="built_in">String</span>&gt; words = lines.flatMap(s -&gt; Lists.newArrayList(SPACE.split(s)));</span><br><span class="line"> JavaPairDStream&lt;<span class="built_in">String</span>, Integer&gt; wordCounts = words.mapToPair(w -&gt; <span class="keyword">new</span> Tuple2&lt;<span class="built_in">String</span>, Integer&gt;(w, <span class="number">1</span>)).reduceByKey((a,b)-&gt;a+b);</span><br><span class="line"></span><br><span class="line"> wordCounts.foreachRDD((rdd,time) -&gt; &#123;</span><br><span class="line">    <span class="built_in">String</span> counts = <span class="string">"Counts at time "</span> + time + <span class="string">" "</span> + rdd.collect();</span><br><span class="line">    System.out.println(counts);</span><br><span class="line">    System.out.println(<span class="string">"Appending to "</span> + outputFile.getAbsolutePath());</span><br><span class="line">    Files.append(counts + <span class="string">"\n"</span>, outputFile, Charset.defaultCharset());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure><h2 id="4、启动-Spark-Streaming"><a href="#4、启动-Spark-Streaming" class="headerlink" title="4、启动 Spark Streaming"></a>4、启动 Spark Streaming</h2><blockquote><p>之前的所有步骤只创建了执行流程，程序没有有真正连接上数据源，也没有对数据进行任何操作，只是设定好了所有的执行计算，当 ssc.start() 启动后，程序才真正进行所有预期的操作。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssc.start();</span><br><span class="line">ssc.awaitTermination();</span><br></pre></td></tr></table></figure><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol><li>Spark Streaming 内部的实现和调度方式高度依赖 Spark 的 DAG 调度器和 RDD，这就决定了 Spark Streaming 的设计初衷必须是粗粒度方式的，同时，由于 Spark 内部调度器足够快速和高效，可以快速地处理小批量数据，这就获得准实时的特性。</li><li>Spark Streaming 的粗粒度执行方式使其确保“处理且仅处理一次”的特性，同时也可以更方便地实现容错恢复机制。</li><li>由于 Spark Streaming 的 DStream 本质是 RDD 在流式数据上的抽象，因此基于 RDD 的各种操作也有相应的基于 DStream 的版本，这样就大大降低了用户对于新框架的学习成本，在了解 Spark 的情况下用户将很容易使用 Spark Streaming。</li><li>由于 DStream 是在 RDD 上的抽象，那么也就更容易与 RDD 进行交互操作，在需要将流式数据和批处理数据结合进行分析的情况下，将会变得非常方便。</li></ol><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ol><li>Spark Streaming 的粗粒度处理方式也造成了不可避免的延迟。在细粒度处理方式下，理想情况下每一条记录都会被实时处理，而在 Spark Streaming 中，数据需要汇总到一定的量后再一次性处理，这就增加了数据处理的延迟，这种延迟是由框架的设计引入的，并不是由网络或其他情况造成的。</li><li>Spark Streaming 当前版本稳定性不是很好。<br>总而言之，Spark Streaming 为我们提供了一种崭新的流式处理框架，相信未来随着 Spark Streaming 会在易用性、稳定性以及其他方面有很大的提升。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=
      
    
    </summary>
    
    
      <category term="spark" scheme="http://yoursite.com/categories/spark/"/>
    
    
      <category term="scala" scheme="http://yoursite.com/tags/scala/"/>
    
      <category term="spark" scheme="http://yoursite.com/tags/spark/"/>
    
      <category term="spark streaming" scheme="http://yoursite.com/tags/spark-streaming/"/>
    
  </entry>
  
  <entry>
    <title>spark streaming 基础与调优</title>
    <link href="http://yoursite.com/2019/10/30/spark-streaming-tuning/"/>
    <id>http://yoursite.com/2019/10/30/spark-streaming-tuning/</id>
    <published>2019-10-29T16:27:23.000Z</published>
    <updated>2019-10-29T17:48:29.651Z</updated>
    
    <content type="html"><![CDATA[<h2 id="spark-streaming的状态更新"><a href="#spark-streaming的状态更新" class="headerlink" title="spark-streaming的状态更新"></a>spark-streaming的状态更新</h2><p>updateStateByKey、reduceByKeyAndWindow<br><strong>必须启用检查点功能，因为有状态的操作是从程序开始时一直进行的</strong></p><h2 id="DStream操作"><a href="#DStream操作" class="headerlink" title="DStream操作"></a>DStream操作</h2><ul><li>与RDD相同的操作方法</li><li>transform：用于直接操作DStream内部的RDD，那些DStream没有提供的RDD操作，可以通过transform调用实现。如join：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val joinedDStream = d.transform(<span class="function"><span class="params">rdd</span> =&gt;</span> &#123;</span><br><span class="line">    rdd.join(rdd2)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><h3 id="窗口操作"><a href="#窗口操作" class="headerlink" title="窗口操作"></a>窗口操作</h3><ul><li>窗口长度<blockquote><p>窗口跨越的周期次数，每次窗口处理的数据分片数</p></blockquote></li><li>滑动区间<blockquote><p>从当前窗口到下一个窗口间隔的周期数量。每次划过的窗口数</p></blockquote></li></ul><p>如果这两个参数的值都是1，则跟不使用窗口效果一样。每个窗口的周期数据都会合并成一个RDD保存在DStream中。</p><ul><li>窗口函数<br>用windowLength、slideInterval生成一个带窗口的DStream，也可以使用加窗口参数的方法：countByWindow、reduceByWindow、reduceByKeyAndWindow、countByValueAndWindow.</li></ul><h3 id="高级操作"><a href="#高级操作" class="headerlink" title="高级操作"></a>高级操作</h3><h4 id="1、缓存与持久化"><a href="#1、缓存与持久化" class="headerlink" title="1、缓存与持久化"></a>1、缓存与持久化</h4><p>窗口函数和updateStateByKey会默认自动持久化<br>从网络接收数据的输入DStream，默认持久化级别是复制数据到两个节点上，以确保容错能力。</p><h4 id="2、打包、发布和监控"><a href="#2、打包、发布和监控" class="headerlink" title="2、打包、发布和监控"></a>2、打包、发布和监控</h4><ul><li>需要提供spark之外的其他所有第三方jar包。</li><li>最好用hdfs或s3的文件系统目录来配置检查点</li><li>配置driver程序自动重启<blockquote><p>standalone模式提交用–deploy-mode cluster –supervise,YARN下选择yarn-cluster，Mesos下通过Marathon协助实现。</p></blockquote></li><li>从1.2开始，支持Write Ahead Logs(WAL)，开启之后，所有收到的数据在处理前会写到检查点目录下，可确保driver重启期间数据不丢失。设置spark.streaming.receiver.writeAheadLog.enable为true开启，会降低数据接收的吞吐量，不过可以通过采用<strong>并发接收</strong>的方式降低影响。如果开启了WAL，可以关闭接受数据时的复制机制：<strong>设置输入DStream的存储级别为StorageLevel.MEMORY_AND_DISK_SER</strong>。</li></ul><h4 id="3、更新程序代码"><a href="#3、更新程序代码" class="headerlink" title="3、更新程序代码"></a>3、更新程序代码</h4><p>为了不丢失数据，可采用一下两种方法：</p><ul><li><strong>新旧程序同时运行。</strong> 等新的程序运行之后，在停止旧的程序。这种方式要求数据源支持同时向新、旧两个版本的程序发数据</li><li><strong>先停止旧的程序再启动新的程序。</strong><br>要保证旧的程序是被优雅的关闭，确保关闭前接收到的数据都处理完了。这种方式只适用于<strong>支持缓存数据功能</strong>的数据源，如Kafka、Flume。启动新的程序时在读取前一个程序的检查点信息时可能出错，因为检查点中一些对象是序列化存储，新的对象结构可能已经改变了。解决办法是：<strong>用新的检查点目录</strong>或者<strong>删除旧的检查点目录下的所有内容</strong>。</li></ul><h2 id="spark-streaming调优方向"><a href="#spark-streaming调优方向" class="headerlink" title="spark streaming调优方向"></a>spark streaming调优方向</h2><h3 id="一、每个批次的处理时间尽可能短"><a href="#一、每个批次的处理时间尽可能短" class="headerlink" title="一、每个批次的处理时间尽可能短"></a>一、每个批次的处理时间尽可能短</h3><h3 id="二、收到数据后尽可能快的处理"><a href="#二、收到数据后尽可能快的处理" class="headerlink" title="二、收到数据后尽可能快的处理"></a>二、收到数据后尽可能快的处理</h3><h2 id="优化方法"><a href="#优化方法" class="headerlink" title="优化方法"></a>优化方法</h2><h3 id="一、减少批处理的时间"><a href="#一、减少批处理的时间" class="headerlink" title="一、减少批处理的时间"></a>一、减少批处理的时间</h3><h4 id="1、增加数据接收的并发数量，尤其当瓶颈发生在数据接收的时候。"><a href="#1、增加数据接收的并发数量，尤其当瓶颈发生在数据接收的时候。" class="headerlink" title="1、增加数据接收的并发数量，尤其当瓶颈发生在数据接收的时候。"></a>1、增加数据接收的并发数量，尤其当瓶颈发生在数据接收的时候。</h4><blockquote><p>默认每个InputDStream只会创建一个接收器，我们可以创建多个让它们接收不同的数据分区，以实现并行接收。</p></blockquote><blockquote><p>比如1个接收2个topic的Kafka InputDStream可以优化为2个InputDStream，各接收一个topic，然后在合并。</p></blockquote><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> numStreams = <span class="number">5</span></span><br><span class="line"><span class="keyword">val</span> kafkaStreams = (<span class="number">1</span> to numStreams).map&#123;</span><br><span class="line">    i =&gt; <span class="type">KafkaUtils</span>.createStream(...)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">val</span> unifiedStream = streamingContext.union(kafkaStreams)</span><br><span class="line">unifiedStream.print()</span><br></pre></td></tr></table></figure><h4 id="2、数据处理的并发度"><a href="#2、数据处理的并发度" class="headerlink" title="2、数据处理的并发度"></a>2、数据处理的并发度</h4><blockquote><p>调整选项spark.default.parallelism</p></blockquote><h4 id="3、task启动的额外开销"><a href="#3、task启动的额外开销" class="headerlink" title="3、task启动的额外开销"></a>3、task启动的额外开销</h4><blockquote><p>如果task启动过于频繁（比如每秒50次），额外的开销可能非常高，甚至无法达到实时计算要求。</p></blockquote><h3 id="二、设置合理批次间隔时间"><a href="#二、设置合理批次间隔时间" class="headerlink" title="二、设置合理批次间隔时间"></a>二、设置合理批次间隔时间</h3><blockquote><p>一般来说短时间间隔会导致更多的额外开销，以及无法完成的风险，所以前期采取相对保守的方法，将间隔设置为5~10秒。然后通过观察运行数据确保系统足够实时，每个间隔的实际计算时间远小于间隔时间，再逐渐缩短间隔时间。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;spark-streaming的状态更新&quot;&gt;&lt;a href=&quot;#spark-streaming的状态更新&quot; class=&quot;headerlink&quot; title=&quot;spark-streaming的状态更新&quot;&gt;&lt;/a&gt;spark-streaming的状态更新&lt;/h2&gt;&lt;
      
    
    </summary>
    
    
      <category term="spark" scheme="http://yoursite.com/categories/spark/"/>
    
    
      <category term="tuning" scheme="http://yoursite.com/tags/tuning/"/>
    
      <category term="scala" scheme="http://yoursite.com/tags/scala/"/>
    
      <category term="spark" scheme="http://yoursite.com/tags/spark/"/>
    
      <category term="spark streaming" scheme="http://yoursite.com/tags/spark-streaming/"/>
    
  </entry>
  
  <entry>
    <title>scala 日志处理实例</title>
    <link href="http://yoursite.com/2019/10/30/scala-log-handle/"/>
    <id>http://yoursite.com/2019/10/30/scala-log-handle/</id>
    <published>2019-10-29T16:24:31.000Z</published>
    <updated>2019-10-29T17:36:01.609Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//日志格式</span></span><br><span class="line"><span class="comment">//100.97.15.241 - - [19/Aug/2016:11:05:47 +0800] "GET /view.php HTTP/1.0" 200 0 "http://www.gooogle.cn/search?q=hadoop" "Mozilla/5.0 (compatible;MSIE 10.0;Windows NT 6.2; Trident/6.0" "-"</span></span><br><span class="line"><span class="comment">// 1. 总PV页面浏览量    </span></span><br><span class="line">lines.count().print()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 各IP的PV，按PV倒序</span></span><br><span class="line"><span class="comment">//   空格分隔的第一个字段就是IP</span></span><br><span class="line">lines.map(line =&gt; &#123;(line.split(<span class="string">" "</span>)(<span class="number">0</span>), <span class="number">1</span>)&#125;).reduceByKey(_ + _).transform(rdd =&gt; &#123;</span><br><span class="line">  rdd.map(ip_pv =&gt; (ip_pv._2, ip_pv._1)).</span><br><span class="line">  sortByKey(<span class="literal">false</span>).</span><br><span class="line">  map(ip_pv =&gt; (ip_pv._2, ip_pv._1))</span><br><span class="line">&#125;).print()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 搜索引擎PV</span></span><br><span class="line"><span class="keyword">val</span> refer = lines.map(_.split(<span class="string">"\""</span>)(<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先输出搜索引擎和查询关键词，避免统计搜索关键词时重复计算</span></span><br><span class="line"><span class="comment">// 输出(host, query_keys)</span></span><br><span class="line"><span class="keyword">val</span> searchEnginInfo = refer.map(r =&gt; &#123;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">val</span> f = r.split('/')</span><br><span class="line">    <span class="comment">//搜索关键字的key</span></span><br><span class="line">    <span class="keyword">val</span> searchEngines = <span class="type">Map</span>(</span><br><span class="line">        <span class="string">"www.google.cn"</span> -&gt; <span class="string">"q"</span>,</span><br><span class="line">        <span class="string">"www.yahoo.com"</span> -&gt; <span class="string">"p"</span>,</span><br><span class="line">        <span class="string">"cn.bing.com"</span> -&gt; <span class="string">"q"</span>,</span><br><span class="line">        <span class="string">"www.baidu.com"</span> -&gt; <span class="string">"wd"</span>,</span><br><span class="line">        <span class="string">"www.sogou.com"</span> -&gt; <span class="string">"query"</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (f.length &gt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">val</span> host = f(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (searchEngines.contains(host)) &#123;</span><br><span class="line">            <span class="keyword">val</span> query = r.split('?')(<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> (query.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">val</span> arr_search_q = query.split('&amp;').filter(_.indexOf(searchEngines(host)+<span class="string">"="</span>) == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">if</span> (arr_search_q.length &gt; <span class="number">0</span>)</span><br><span class="line">                    (host, arr_search_q(<span class="number">0</span>).split('=')(<span class="number">1</span>))</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    (host, <span class="string">""</span>)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                (host, <span class="string">""</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            (<span class="string">""</span>, <span class="string">""</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        (<span class="string">""</span>, <span class="string">""</span>)</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出搜索引擎PV</span></span><br><span class="line">searchEnginInfo.filter(_._1.length &gt; <span class="number">0</span>).map(p =&gt; &#123;(p._1, <span class="number">1</span>)&#125;).reduceByKey(_ + _).print()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 关键词PV</span></span><br><span class="line">searchEnginInfo.filter(_._2.length &gt; <span class="number">0</span>).map(p =&gt; &#123;(p._2, <span class="number">1</span>)&#125;).reduceByKey(_ + _).print()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 终端类型PV</span></span><br><span class="line">lines.map(_.split(<span class="string">"\""</span>)(<span class="number">5</span>)).map(agent =&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> types = <span class="type">Seq</span>(<span class="string">"iPhone"</span>, <span class="string">"Android"</span>)</span><br><span class="line">    <span class="keyword">var</span> r = <span class="string">"Default"</span></span><br><span class="line">    <span class="keyword">for</span> (t &lt;- types) &#123;</span><br><span class="line">        <span class="keyword">if</span> (agent.indexOf(t) != <span class="number">-1</span>)</span><br><span class="line">            r = t</span><br><span class="line">    &#125;</span><br><span class="line">    (r, <span class="number">1</span>)</span><br><span class="line">&#125;).reduceByKey(_ + _).print()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 6. 各页面PV</span></span><br><span class="line">lines.map(line =&gt; &#123;(line.split(<span class="string">"\""</span>)(<span class="number">1</span>).split(<span class="string">" "</span>)(<span class="number">1</span>), <span class="number">1</span>)&#125;).reduceByKey(_ + _).print()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight scala&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class
      
    
    </summary>
    
    
      <category term="scala" scheme="http://yoursite.com/categories/scala/"/>
    
    
      <category term="scala" scheme="http://yoursite.com/tags/scala/"/>
    
      <category term="spark" scheme="http://yoursite.com/tags/spark/"/>
    
      <category term="functional programming" scheme="http://yoursite.com/tags/functional-programming/"/>
    
  </entry>
  
  <entry>
    <title>scala 学习入门</title>
    <link href="http://yoursite.com/2019/10/30/scala-learning/"/>
    <id>http://yoursite.com/2019/10/30/scala-learning/</id>
    <published>2019-10-29T16:04:17.000Z</published>
    <updated>2019-10-29T17:35:45.036Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h2><blockquote><p>大部分都能隐式转换，Byte、Short需要显式指定</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val little : Byte = <span class="number">3</span></span><br><span class="line">val little:Short = <span class="number">3</span></span><br></pre></td></tr></table></figure><blockquote><p>char、String支持\转义</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val a = <span class="string">'a'</span>    <span class="comment">//char = 'a'</span></span><br><span class="line">val str = <span class="string">"hello \101"</span>      <span class="comment">//String=hello A</span></span><br></pre></td></tr></table></figure><blockquote><p>带小数点的默认为Double，以F结尾表示Float</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val pi = <span class="number">3.14</span>F</span><br><span class="line">val pi = <span class="number">3.14</span> <span class="comment">// double</span></span><br></pre></td></tr></table></figure><h2 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fun = <span class="function">(<span class="params">v : Int</span>) =&gt;</span> v + <span class="number">1</span>  <span class="comment">//匿名函数赋值给一个变量</span></span><br><span class="line">def addOne(v : Int) : Int = v + <span class="number">1</span>  <span class="comment">//非匿名函数</span></span><br></pre></td></tr></table></figure><h2 id="控制结构"><a href="#控制结构" class="headerlink" title="控制结构"></a>控制结构</h2><blockquote><p>if表达式</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val filename = </span><br><span class="line"><span class="keyword">if</span> (!args.isEmpty) args(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">else</span> <span class="string">"default.txt"</span></span><br></pre></td></tr></table></figure><blockquote><p>while循环</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//计算最大公约数</span></span><br><span class="line">def gcdLoop(x : Long,<span class="attr">y</span>: Long) : Long = &#123;</span><br><span class="line">    <span class="keyword">var</span> a = x</span><br><span class="line">    <span class="keyword">var</span> b = y</span><br><span class="line">    <span class="keyword">while</span> (a != <span class="number">0</span>)&#123;</span><br><span class="line">        val temp = a;</span><br><span class="line">        a = b % a;</span><br><span class="line">        b = temp</span><br><span class="line">    &#125;</span><br><span class="line">    b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>do…while</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> line = <span class="string">""</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    line = readLine()</span><br><span class="line">    println(<span class="string">"read:"</span>+line)</span><br><span class="line">&#125;<span class="keyword">while</span>(line != <span class="string">""</span>)</span><br></pre></td></tr></table></figure><blockquote><p>for表达式</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>( i &lt;- <span class="number">1</span> to <span class="number">4</span>)</span><br><span class="line">    println(<span class="string">"Iteration "</span>+ i)</span><br></pre></td></tr></table></figure><blockquote><p>try…catch</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">def g() : Int = &#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="number">1</span>/<span class="number">0</span></span><br><span class="line">    &#125;<span class="keyword">catch</span>&#123;</span><br><span class="line">        <span class="keyword">case</span> ex: <span class="function"><span class="params">ArithmeticException</span> =&gt;</span> &#123;</span><br><span class="line">            ex.toString</span><br><span class="line">            <span class="number">2</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> _ :<span class="function"><span class="params">Throwable</span> =&gt;</span> <span class="number">3</span></span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        println(<span class="string">"finally"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="基本数据结构"><a href="#基本数据结构" class="headerlink" title="基本数据结构"></a>基本数据结构</h2><blockquote><p>数组Array：可修改，通过括号()来引用</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val greeting = <span class="keyword">new</span> <span class="built_in">Array</span>[<span class="built_in">String</span>](<span class="number">2</span>)</span><br><span class="line">greeting(<span class="number">0</span>) = <span class="string">"hello"</span></span><br></pre></td></tr></table></figure><blockquote><p>列表List：只读</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val numbers = List(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">numbers(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><blockquote><p>元组Tuple：只读，与List类似，可以是不同元素,下标从1开始</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val hostPort = (<span class="string">"localhost"</span>,<span class="number">80</span>)</span><br><span class="line">hostPort._1</span><br><span class="line">hostPort._2</span><br></pre></td></tr></table></figure><blockquote><p>集合Set：只读，没有重复的元素</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Set</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>)</span><br></pre></td></tr></table></figure><blockquote><p>映射Map:</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">val m = <span class="built_in">Map</span>(<span class="number">1</span> -&gt; <span class="string">"one"</span>,<span class="number">2</span> -&gt; <span class="string">"two"</span>)</span><br><span class="line">m(<span class="number">2</span>)</span><br><span class="line"><span class="comment">//创建可写版本</span></span><br><span class="line">val m = scala.collection.mutable.Map[Int,<span class="built_in">String</span>](<span class="number">1</span> -&gt; <span class="string">"one"</span>,<span class="number">2</span> -&gt; <span class="string">"two"</span>)</span><br><span class="line">m += (<span class="number">3</span> -&gt; <span class="string">"three"</span>)</span><br><span class="line">m(<span class="number">4</span>)=<span class="string">"four"</span></span><br><span class="line">m -= <span class="number">2</span></span><br></pre></td></tr></table></figure><h2 id="定义class"><a href="#定义class" class="headerlink" title="定义class"></a>定义class</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Hello( _a : Int) &#123;</span><br><span class="line">    private val a = _a;</span><br><span class="line">    println(<span class="string">"initializing...("</span> + _a + “） ”);</span><br><span class="line">    def add( b : Int) : Int = a + b;</span><br><span class="line">    def <span class="keyword">this</span>() = <span class="keyword">this</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class Hello2(a : Int) extends Hello(a) &#123;</span><br><span class="line">    def add(b : Int, <span class="attr">c</span> : Int) : Int = a + b+ c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="单实例对象"><a href="#单实例对象" class="headerlink" title="单实例对象"></a>单实例对象</h2><blockquote><p>scala 不支持static变量、成员，但提供了单例对象，用object来定义</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">object Timer &#123;</span><br><span class="line">    <span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line">    def currentCount() : Long = &#123;</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        count</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Timer.currentCount()</span><br></pre></td></tr></table></figure><blockquote><p>单例对象可以和类具有相同的名字，放在同一个源文件，可以相互访问彼此的private方法和变量。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Bar(foo : String)</span><br><span class="line">object Bar&#123;</span><br><span class="line">    def apply(foo : <span class="built_in">String</span>) = <span class="keyword">new</span> Bar(foo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(x:Int) =&gt; x+<span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> incr = <span class="function">(<span class="params">x:Int</span>) =&gt;</span> x+<span class="number">1</span></span><br><span class="line">incr(<span class="number">10</span>)</span><br></pre></td></tr></table></figure><h2 id="匿名函数作为参数"><a href="#匿名函数作为参数" class="headerlink" title="匿名函数作为参数"></a>匿名函数作为参数</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">val someNumbers = List(<span class="number">1</span>,<span class="number">3</span>,<span class="number">-2</span>,<span class="number">0</span>)</span><br><span class="line">someNumbers.filter( <span class="function"><span class="params">x</span> =&gt;</span> x &gt; <span class="number">0</span> )</span><br><span class="line"><span class="comment">//如果匿名函数的参数只被使用一次，可以直接写函数体，用_代替一个参数</span></span><br><span class="line">someNumbers.filter(_ &gt; <span class="number">0</span>)</span><br></pre></td></tr></table></figure><h2 id="函数嵌套"><a href="#函数嵌套" class="headerlink" title="函数嵌套"></a>函数嵌套</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scala.io.Source</span><br><span class="line">def processFile(filename : <span class="built_in">String</span>)&#123;</span><br><span class="line">    def processLine(line : <span class="built_in">String</span>)&#123;</span><br><span class="line">        println(line)</span><br><span class="line">    &#125;</span><br><span class="line">    Source.fromFile(filename).getLines.foreach(processLine);</span><br><span class="line">&#125;</span><br><span class="line">processFile(<span class="string">"t.scala"</span>)</span><br></pre></td></tr></table></figure><h2 id="部分应用函数"><a href="#部分应用函数" class="headerlink" title="部分应用函数"></a>部分应用函数</h2><blockquote><p>函数的参数可以分步提供</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def adder(m : Int,<span class="attr">n</span> : Int, <span class="attr">z</span> : Int) : Int = m + n + z</span><br><span class="line">val adder2 = adder(<span class="number">2</span>,<span class="attr">_</span>:Int,<span class="attr">_</span>:Int) <span class="comment">//部分应用函数，只输入参数2，用_代替没有准备好的另一个参数</span></span><br><span class="line">val adder3 = add2(<span class="number">3</span>,<span class="attr">_</span>:Int)</span><br><span class="line">adder3(<span class="number">4</span>)  <span class="comment">//9</span></span><br></pre></td></tr></table></figure><h2 id="柯里化函数currying"><a href="#柯里化函数currying" class="headerlink" title="柯里化函数currying"></a>柯里化函数currying</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//非柯里化函数</span></span><br><span class="line">def plainSum(x : Int,<span class="attr">y</span> : Int) = x + y;</span><br><span class="line">plainSum(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"><span class="comment">//柯里化</span></span><br><span class="line">def curriedSum(x:Int)(y:Int) = x + y</span><br><span class="line"><span class="comment">//可以一次输入两个参数来调用</span></span><br><span class="line">curriedSum(<span class="number">1</span>)(<span class="number">2</span>)</span><br><span class="line">val onePlus = curriedSum(<span class="number">1</span>)_  <span class="comment">//使用了部分应用函数符号_</span></span><br><span class="line">onePlus(<span class="number">2</span>)</span><br><span class="line">val twoPlus = curriedSum(<span class="number">2</span>)_</span><br><span class="line">twoPlus(<span class="number">3</span>)  <span class="comment">//5</span></span><br></pre></td></tr></table></figure><h2 id="包"><a href="#包" class="headerlink" title="包"></a>包</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">package org.scala.example</span><br><span class="line">object Color&#123;</span><br><span class="line">    val BLUE = <span class="string">"Blue"</span></span><br><span class="line">    val Green = <span class="string">"Green"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">times match&#123;</span><br><span class="line">   <span class="keyword">case</span> <span class="number">1</span> =&gt; <span class="string">"one"</span></span><br><span class="line">   <span class="keyword">case</span> <span class="number">2</span> =&gt; <span class="string">"two"</span></span><br><span class="line">   <span class="keyword">case</span> <span class="function"><span class="params">_</span> =&gt;</span> <span class="string">"some other"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对象匹配</span></span><br><span class="line">def bigger(o : Any) : Any = &#123;</span><br><span class="line">   o match &#123;</span><br><span class="line">       <span class="keyword">case</span> i : Int <span class="keyword">if</span> i &gt; <span class="number">0</span> =&gt; i - <span class="number">1</span></span><br><span class="line">       <span class="keyword">case</span> i : <span class="function"><span class="params">Int</span> =&gt;</span> i + <span class="number">1</span></span><br><span class="line">       <span class="keyword">case</span> d: Double <span class="keyword">if</span> d &gt; <span class="number">0.0</span> =&gt; d - <span class="number">0.1</span></span><br><span class="line">       <span class="keyword">case</span> d: <span class="function"><span class="params">Double</span> =&gt;</span> d + <span class="number">0.1</span></span><br><span class="line">       <span class="keyword">case</span> text:<span class="function"><span class="params">String</span> =&gt;</span> text + <span class="string">"s"</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">val v42 = <span class="number">42</span></span><br><span class="line"><span class="comment">// print Not 42</span></span><br><span class="line">Some(<span class="number">3</span>) match &#123;</span><br><span class="line">   <span class="keyword">case</span> Some(<span class="string">`v42`</span>) =&gt; println(<span class="string">"42"</span>)</span><br><span class="line">   <span class="keyword">case</span> <span class="function"><span class="params">_</span> =&gt;</span> println(<span class="string">"Not 42"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="scala应用程序"><a href="#scala应用程序" class="headerlink" title="scala应用程序"></a>scala应用程序</h2><blockquote><p>入口：单实例对象，内部必须有一个main方法，main有且仅有一个Array[String]的参数，并且返回Unit</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Hello.scala</span></span><br><span class="line">object Hello&#123;</span><br><span class="line">    def main(args : <span class="built_in">Array</span>[<span class="built_in">String</span>]) &#123;</span><br><span class="line">        <span class="keyword">for</span> (arg &lt;- args)</span><br><span class="line">            println(<span class="string">"hello "</span> + arg)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行：</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; scala Hello scala spark</span><br><span class="line">//<span class="built_in">print</span></span><br><span class="line">hello scala</span><br><span class="line">hello spark</span><br></pre></td></tr></table></figure><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">var</span> more =<span class="number">1</span></span><br><span class="line">more: Int = <span class="number">1</span></span><br><span class="line">scala&gt; val addMore = <span class="function">(<span class="params">x:Int</span>) =&gt;</span> x + more</span><br><span class="line">addMore: <span class="function"><span class="params">Int</span> =&gt;</span> Int = <span class="xml"><span class="tag">&lt;<span class="name">function1</span>&gt;</span></span></span><br><span class="line"><span class="xml">scala&gt; addMore (100)</span></span><br><span class="line"><span class="xml">res1: Int = 101</span></span><br><span class="line"><span class="xml">//addMore为闭包，引用了外部变量more。当这个自由变量发生变化时，Scala 的闭包能够捕获到这个变化，因此 Scala 的闭包捕获的是**变量本身**而不是当时变量的值。</span></span><br><span class="line"><span class="xml">scala&gt; more =  9999</span></span><br><span class="line"><span class="xml">more: Int = 9999</span></span><br><span class="line"><span class="xml">scala&gt; addMore ( 10)</span></span><br><span class="line"><span class="xml">res2: Int = 10009</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">如果变量在闭包在发生变化，也会反映到函数外面定义的闭包的值。比如：</span></span><br><span class="line"><span class="xml">scala&gt; val someNumbers = List ( -11, -10, -5, 0, 5, 10)</span></span><br><span class="line"><span class="xml">someNumbers: List[Int] = List(-11, -10, -5, 0, 5, 10)</span></span><br><span class="line"><span class="xml">scala&gt; var sum =0</span></span><br><span class="line"><span class="xml">sum: Int = 0</span></span><br><span class="line"><span class="xml">scala&gt; someNumbers.foreach ( sum += _)</span></span><br><span class="line"><span class="xml">scala&gt; sum</span></span><br><span class="line"><span class="xml">res4: Int = -11</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;基本类型&quot;&gt;&lt;a href=&quot;#基本类型&quot; class=&quot;headerlink&quot; title=&quot;基本类型&quot;&gt;&lt;/a&gt;基本类型&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;大部分都能隐式转换，Byte、Short需要显式指定&lt;/p&gt;
&lt;/blockquote&gt;
&lt;fig
      
    
    </summary>
    
    
      <category term="scala" scheme="http://yoursite.com/categories/scala/"/>
    
    
      <category term="scala" scheme="http://yoursite.com/tags/scala/"/>
    
  </entry>
  
</feed>
