<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>running-in-sky</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.zzzhy.cn/"/>
  <updated>2019-12-04T14:39:40.855Z</updated>
  <id>http://www.zzzhy.cn/</id>
  
  <author>
    <name>zzzhy</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>service-mesh-op-with-istio</title>
    <link href="http://www.zzzhy.cn/2019/12/04/service-mesh-op-with-istio/"/>
    <id>http://www.zzzhy.cn/2019/12/04/service-mesh-op-with-istio/</id>
    <published>2019-12-04T14:37:08.000Z</published>
    <updated>2019-12-04T14:39:40.855Z</updated>
    
    <content type="html"><![CDATA[<h3 id="服务治理的三种发展形态"><a href="#服务治理的三种发展形态" class="headerlink" title="服务治理的三种发展形态"></a>服务治理的三种发展形态</h3><ul><li>应用程序中包含治理逻辑</li><li>治理逻辑独立的代码（SDK模式）</li><li>治理逻辑独立的进程（SIDECAR模式）</li></ul><h3 id="spring-cloud-k8s-与-istio-k8s的比较"><a href="#spring-cloud-k8s-与-istio-k8s的比较" class="headerlink" title="spring cloud + k8s 与 istio + k8s的比较"></a>spring cloud + k8s 与 istio + k8s的比较</h3><table><thead><tr><th>项目</th><th>istio + k8s</th><th>spring cloud + k8s</th></tr></thead><tbody><tr><td>架构设计</td><td>基于Kubernetes能力构建</td><td>和Kubernetes无结合</td></tr><tr><td>服务发现</td><td>使用k8s服务名，和k8s一致的服务发现机制</td><td>两套服务发现。有服务发现数据不一致的问题。k8s中pod的正常歉意会引起重新进行服务注册</td></tr><tr><td>使用体验</td><td>完全的k8s使用体验。sidecar自动注入pod，业务无感知，和部署普通k8s服务无差别。</td><td>和k8s无结合，k8s只是提供了运行环境</td></tr><tr><td>控制面</td><td>无序额外的APIServer和规则策略定义。基于k8s CRD进行扩展。</td><td>需自行安装和维护控制面来管理治理规则。</td></tr></tbody></table><h3 id="istio的几个约束"><a href="#istio的几个约束" class="headerlink" title="istio的几个约束"></a>istio的几个约束</h3><ul><li><p>端口命名：</p><p>服务端口必须进行命名，而且名称只能是protocol[-<suffix>]形式，protocol可以使tcp、http、http2、https、mysql、redis等。istio根据端口定义的协议提供对应的路由能力。如果端口未命名或没有基于这种格式，则端口的流量会当成tcp流量来处理。</p></li><li><p>服务关联</p><p>如果一个pod属于多个k8s服务，则要求服务不能再同一个端口使用不同的协议。</p></li><li><p>Deployment使用app和version标签：</p><p>每个deployment都需要一个有业务意义的app标签和一个表示版本的version标签。分布式追踪可以通过app标签补齐上下文信息，还可以通过app和version为遥测数据补齐上下文信息。</p></li></ul><h3 id="openshift-deploy组件的注入问题"><a href="#openshift-deploy组件的注入问题" class="headerlink" title="openshift deploy组件的注入问题"></a>openshift deploy组件的注入问题</h3><p>当开启了namespace的自动注入，又是在用openshift的deploy进行服务部署时，会发生deploy组件complete之后istio-proxy容器不会停止。这时，我们可以修改下istio-inject的ConfigMap配置：</p><p>当检测到</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">neverInjectSelector:</span></span><br><span class="line"><span class="attr">  - matchExpressions:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">&#123;key:</span> <span class="string">openshift.io/build.name,</span> <span class="attr">operator:</span> <span class="string">Exists&#125;</span></span><br><span class="line"><span class="attr">  - matchExpressions:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">&#123;key:</span> <span class="string">openshift.io/deployer-pod-for.name,</span> <span class="attr">operator:</span> <span class="string">Exists&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;服务治理的三种发展形态&quot;&gt;&lt;a href=&quot;#服务治理的三种发展形态&quot; class=&quot;headerlink&quot; title=&quot;服务治理的三种发展形态&quot;&gt;&lt;/a&gt;服务治理的三种发展形态&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;应用程序中包含治理逻辑&lt;/li&gt;
&lt;li&gt;治理逻辑独立的
      
    
    </summary>
    
    
      <category term="cloud native" scheme="http://www.zzzhy.cn/categories/cloud-native/"/>
    
    
      <category term="cloud native,istio,k8s" scheme="http://www.zzzhy.cn/tags/cloud-native-istio-k8s/"/>
    
  </entry>
  
  <entry>
    <title>理解kubernetes架构及组件</title>
    <link href="http://www.zzzhy.cn/2019/11/13/k8s-arch/"/>
    <id>http://www.zzzhy.cn/2019/11/13/k8s-arch/</id>
    <published>2019-11-13T15:12:00.000Z</published>
    <updated>2019-11-14T16:29:48.607Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Kubernetes集群架构"><a href="#Kubernetes集群架构" class="headerlink" title="Kubernetes集群架构"></a>Kubernetes集群架构</h3><img src="/uploads/k8s-arch.png" alt="image-20191113230229077" style="zoom:50%;" /><h4 id="控制面板"><a href="#控制面板" class="headerlink" title="控制面板"></a>控制面板</h4><p>包含多个组件，组件分别部署在多个主节点保证高可用：</p><ul><li>Kubernetes API服务器</li><li>Scheduler</li><li>Controller Manager 执行集群级别的任务，如复制组件、持续跟踪工作节点、处理节点失败等</li><li>etcd 持久化存储集群配置</li></ul><h4 id="工作节点"><a href="#工作节点" class="headerlink" title="工作节点"></a>工作节点</h4><p>运行容器化应用的机器，也包含多个组件：</p><ul><li>Docker、rtk或其他的容器类型</li><li>Kubelet，他与API服务器通信，管理他所在节点的容器</li><li>Kubernetes Service Proxy（kube-proxy）负责组件之间的负载均衡网络流量</li></ul><h3 id="Kubernetes-强大的标签"><a href="#Kubernetes-强大的标签" class="headerlink" title="Kubernetes 强大的标签"></a>Kubernetes 强大的标签</h3><h4 id="kubernetes标签选择器"><a href="#kubernetes标签选择器" class="headerlink" title="kubernetes标签选择器"></a>kubernetes标签选择器</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 根据标签值筛选</span></span><br><span class="line">kubectl get po -l createion_method=manual</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出包含某标签的pod</span></span><br><span class="line">kubectl get po -l env</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出不存在某标签</span></span><br><span class="line">kubectl get po -l <span class="string">'!env'</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出值匹配的</span></span><br><span class="line">kubectl get po -l create_method!=manual</span><br><span class="line">kubectl get po -l env <span class="keyword">in</span> (prod,dev)</span><br><span class="line">kubectl get po -l env notin (prod,dev)</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 多条件</span></span><br><span class="line">kubect get po -l app=pc,env=prod</span><br></pre></td></tr></table></figure><h4 id="利用标签约束pod调度"><a href="#利用标签约束pod调度" class="headerlink" title="利用标签约束pod调度"></a>利用标签约束pod调度</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 利用标签分类工作节点</span></span><br><span class="line">kubectl label node xxxxxxxxxxx gpu=<span class="literal">true</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 2. 将pod调度到gpu节点</span></span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: kubia-gpu</span><br><span class="line">spec:</span><br><span class="line">  nodeSelector:</span><br><span class="line">    gpu: <span class="literal">true</span>        <span class="comment"># 要求k8s将pod部署在gpu节点</span></span><br><span class="line">  containers:</span><br><span class="line">  - image: lukas/kubia</span><br><span class="line">    name: kubia</span><br></pre></td></tr></table></figure><h3 id="Kubernetes探针"><a href="#Kubernetes探针" class="headerlink" title="Kubernetes探针"></a>Kubernetes探针</h3><h4 id="存活探针liveness-probe"><a href="#存活探针liveness-probe" class="headerlink" title="存活探针liveness probe"></a>存活探针liveness probe</h4><ul><li>HTTP Get 探针。返回码为2xx或3xx，则认为成功，否则容器将被重新启动</li><li>TCP套接字探针。尝试与容器指定端口建立套接字链接</li><li>Exec探针。在容器内执行任意命令并检查命令的退出命令码，正常退出码为0</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">kubia-liveness</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">  - image:</span> <span class="string">luksa/kubia-unhealthy</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">kubia</span></span><br><span class="line"><span class="attr">    livenessProbe:</span></span><br><span class="line"><span class="attr">      httpGet:</span></span><br><span class="line"><span class="attr">        path:</span> <span class="string">/</span></span><br><span class="line"><span class="attr">        port:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">      initialDelaySeconds:</span> <span class="number">10</span></span><br></pre></td></tr></table></figure><h4 id="就绪探针readinessProbe"><a href="#就绪探针readinessProbe" class="headerlink" title="就绪探针readinessProbe"></a>就绪探针readinessProbe</h4><p>和存活探针一样的类型种类</p><h3 id="Kubernetes-ReplicationController"><a href="#Kubernetes-ReplicationController" class="headerlink" title="Kubernetes ReplicationController"></a>Kubernetes ReplicationController</h3><ol><li>好处<ul><li>确保一个或多个pod副本持续运行，pod故障后会自动启动一个新的pod</li><li>节点故障后也会在其他节点创建替代副本：节点故障时节点状态变为NotReady。k8s会等待一段时间，然后将pod状态变成Unknown，然后立即启动一个新的pod</li><li>轻松实现pod的水平伸缩</li></ul></li><li>定义</li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ReplicationController</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">kubia</span><span class="comment">#ReplicationController名字</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  replicas:</span> <span class="number">3</span><span class="comment">#pod副本数</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">kubia</span></span><br><span class="line"><span class="attr">  template:</span><span class="comment">#ReplicationController管理的pod的模板</span></span><br><span class="line"><span class="attr">    metadata:</span></span><br><span class="line"><span class="attr">      labels:</span></span><br><span class="line"><span class="attr">        app:</span> <span class="string">kubia</span><span class="comment">#pod的标签</span></span><br><span class="line"><span class="attr">    spec:</span></span><br><span class="line"><span class="attr">      containers:</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">kubia</span></span><br><span class="line"><span class="attr">        image:</span> <span class="string">luksa/kubia</span></span><br><span class="line"><span class="attr">        ports:</span></span><br><span class="line"><span class="attr">        - containerPort:</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure><ol start="3"><li><p>针对修改—关于标签和模板</p><ul><li><p>删除ReplicationController时会连带删除掉它所管理的所有pod</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可以通过增加cascade保持pod运行</span></span><br><span class="line">kubectl delete rc kubia --cascade=<span class="literal">false</span></span><br></pre></td></tr></table></figure></li><li><p>ReplicationController运行后新增pod标签不会影响ReplicationController的副本数目</p></li><li><p>删除或修改pod的selector标签，该pod将被移出ReplicationController的管理，ReplicationController会新建一个pod保证副本数</p></li><li><p>修改ReplicationController的模板不会对当前pod造成影响，只会影响之后新建的pod</p></li></ul></li><li><p>伸缩</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl scale rc kubia --replicas=5</span><br></pre></td></tr></table></figure><h3 id="Kubernetes-ReplicaSet"><a href="#Kubernetes-ReplicaSet" class="headerlink" title="Kubernetes ReplicaSet"></a>Kubernetes ReplicaSet</h3><p>ReplicationController的替代。</p><p>行为与ReplicationController一致，但是pod选择器的表达能力更强。比如ReplicaSet可以同时匹配多组标签，而且可以基于标签名的存在性来匹配。</p><ol><li><p>定义</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ReplicaSet</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">kubia</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  replicas:</span> <span class="number">3</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    matchLabels:</span><span class="comment">#多个标签的匹配，也可以是</span></span><br><span class="line"><span class="attr">      app:</span> <span class="string">kubia</span></span><br><span class="line"><span class="attr">  template:</span></span><br><span class="line"><span class="attr">    metadata:</span></span><br><span class="line"><span class="attr">      labels:</span></span><br><span class="line"><span class="attr">        app:</span> <span class="string">kubia</span></span><br><span class="line"><span class="attr">    spec:</span></span><br><span class="line"><span class="attr">      containers:</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">kubia</span></span><br><span class="line"><span class="attr">        image:</span> <span class="string">luksa/kubia</span></span><br></pre></td></tr></table></figure></li><li><p>增强型标签选择器</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">selector:</span></span><br><span class="line"><span class="attr">  matchExpressions:</span></span><br><span class="line"><span class="attr">    - key:</span> <span class="string">app</span>  <span class="comment"># 标签名字</span></span><br><span class="line">      <span class="comment">#In NotIn Exists(包含，不指定values) DoesNotExist（不得包含，不指定values）</span></span><br><span class="line"><span class="attr">      operator:</span> <span class="string">In</span>     </span><br><span class="line"><span class="attr">      values:</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">kubia</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="Kubernetes-DaemonSet"><a href="#Kubernetes-DaemonSet" class="headerlink" title="Kubernetes DaemonSet"></a>Kubernetes DaemonSet</h3><p>在匹配某标签的每个节点上，启动一个Daemon pod。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">DaemonSet</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">ssd-monitor-ds</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    matchLabels:</span></span><br><span class="line"><span class="attr">      app:</span> <span class="string">ssd-monitor</span></span><br><span class="line"><span class="attr">  template:</span></span><br><span class="line"><span class="attr">    metadata:</span></span><br><span class="line"><span class="attr">      labels:</span></span><br><span class="line"><span class="attr">        app:</span> <span class="string">ssd-monitor</span></span><br><span class="line"><span class="attr">    spec:</span></span><br><span class="line"><span class="attr">      nodeSelector:</span></span><br><span class="line"><span class="attr">        disk:</span> <span class="string">ssd</span>      <span class="comment"># 每个标记为ssd的节点都会部署一个标记label为ssd-monitor的pod</span></span><br><span class="line"><span class="attr">      containers:</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">main</span></span><br><span class="line"><span class="attr">        image:</span> <span class="string">luksa/ssd-monitor</span></span><br></pre></td></tr></table></figure><p>如果节点的标签从ssd修改为hdd，则对应的pod也会跟着终止掉。</p><h3 id="Kubernetes-Job"><a href="#Kubernetes-Job" class="headerlink" title="Kubernetes Job"></a>Kubernetes Job</h3><p>Job的内部进程成功结束后，不重启容器，处于完成状态。如果进程异常退出，可以将Job配置为重新启动。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">batch/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Job</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">batch-job</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  template:</span></span><br><span class="line"><span class="attr">    metadata:</span></span><br><span class="line"><span class="attr">      labels:</span></span><br><span class="line"><span class="attr">        app:</span> <span class="string">batch-job</span></span><br><span class="line"><span class="attr">    spec:</span></span><br><span class="line"><span class="attr">      restartPolicy:</span> <span class="string">OnFailure</span>      <span class="comment"># 不能设置为Always自动重启</span></span><br><span class="line"><span class="attr">      containers:</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">main</span></span><br><span class="line"><span class="attr">        image:</span> <span class="string">luksa/batch-job</span></span><br></pre></td></tr></table></figure><p>Job可以创建多个pod实例，一并行或串行方式运行。通过配置completions和parallelism属性。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">batch/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Job</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">multi-completion-batch-job</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  completion:</span> <span class="number">5</span></span><br><span class="line"><span class="attr">  parallelism:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">  template:</span></span><br><span class="line"><span class="attr">    metadata:</span></span><br><span class="line"><span class="attr">      labels:</span></span><br><span class="line"><span class="attr">        app:</span> <span class="string">batch-job</span></span><br><span class="line"><span class="attr">    spec:</span></span><br><span class="line"><span class="attr">      restartPolicy:</span> <span class="string">OnFailure</span>  </span><br><span class="line"><span class="attr">      containers:</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">main</span></span><br><span class="line"><span class="attr">        image:</span> <span class="string">luksa/batch-job</span></span><br></pre></td></tr></table></figure><p>运行逻辑：第一个pod运行完成，继续创建第二个，相当于相同的逻辑起5次pod来执行。</p><p>当parallelism&gt;1时，表示可以同时有parallelism个pod同时运行。</p><h4 id="CronJob"><a href="#CronJob" class="headerlink" title="CronJob"></a>CronJob</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">batch/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">CronJob</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">batch-job-every-fifteen-minutes</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  schedule:</span> <span class="string">"0,15,30,45 * * * *"</span>  <span class="comment"># 每小时0，15，30，45分执行</span></span><br><span class="line"><span class="attr">  jobTemplate:</span></span><br><span class="line"><span class="attr">    spec:</span></span><br><span class="line"><span class="attr">      template:</span></span><br><span class="line"><span class="attr">        metadata:</span></span><br><span class="line"><span class="attr">          labels:</span></span><br><span class="line"><span class="attr">            app:</span> <span class="string">periodic-batch-job</span></span><br><span class="line"><span class="attr">        spec:</span></span><br><span class="line"><span class="attr">          restartPolicy:</span> <span class="string">OnFailure</span></span><br><span class="line"><span class="attr">          containers:</span> </span><br><span class="line"><span class="attr">          - name:</span> <span class="string">main</span></span><br><span class="line"><span class="attr">            image:</span> <span class="string">luksa/batch-job</span></span><br></pre></td></tr></table></figure><h3 id="Kubernetes-Service-—-集群内部服务"><a href="#Kubernetes-Service-—-集群内部服务" class="headerlink" title="Kubernetes Service — 集群内部服务"></a>Kubernetes Service — 集群内部服务</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">kubia</span></span><br><span class="line"><span class="attr">spec:</span> </span><br><span class="line">  <span class="comment">#sessionAffinity: ClientIP  是否保持会话亲和，所有来自同一个clientip的请求会发给同一个pod</span></span><br><span class="line"><span class="attr">  ports:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">http</span>          <span class="comment"># 端口命名</span></span><br><span class="line"><span class="attr">    port:</span> <span class="number">80</span>            <span class="comment"># 暴露出去的端口</span></span><br><span class="line"><span class="attr">    targetPort:</span> <span class="number">8080</span>    <span class="comment"># 容器内部的服务端口，这里也可使用pod里ports的名字代替</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">https</span></span><br><span class="line"><span class="attr">    port:</span> <span class="number">443</span></span><br><span class="line"><span class="attr">    targetPort:</span> <span class="number">8443</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">kubia</span>          <span class="comment"># 标签为kubia的pod都属于这个服务</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">➜  k8s-in-action kubectl get po</span><br><span class="line">NAME                                               READY   STATUS      RESTARTS   AGE</span><br><span class="line">batch-job-every-fifteen-minutes-1573700400-skbmv   0/1     Completed   0          10m</span><br><span class="line">batch-job-r9pkj                                    0/1     Completed   0          36m</span><br><span class="line">kubia-bbt27                                        1/1     Running     0          3m58s</span><br><span class="line">kubia-h5cjl                                        1/1     Running     0          3m58s</span><br><span class="line">kubia-ttv72                                        1/1     Running     0          3m58s</span><br><span class="line"></span><br><span class="line">➜  k8s-in-action kubectl get svc</span><br><span class="line">NAME         TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)   AGE</span><br><span class="line">kubernetes   ClusterIP   10.96.0.1      &lt;none&gt;        443/TCP   10h</span><br><span class="line">kubia        ClusterIP   10.104.37.60   &lt;none&gt;        80/TCP    5m33s</span><br><span class="line"></span><br><span class="line">➜  k8s-in-action kubectl <span class="built_in">exec</span> kubia-h5cjl -- curl -s http://10.104.37.60</span><br><span class="line">You<span class="string">'ve hit kubia-bbt27</span></span><br><span class="line"><span class="string">➜  k8s-in-action kubectl exec kubia-h5cjl -- curl -s http://10.104.37.60</span></span><br><span class="line"><span class="string">You'</span>ve hit kubia-ttv72</span><br></pre></td></tr></table></figure><blockquote><p>– 双横杠表示kubectl命令的结束。横杠之后的内容指需要在pod内部执行的命令。如果后面的命令不带横杠参数，如不带-s，则双横杠不是必须的。</p></blockquote><h3 id="Kubernetes-Endpoints-—-使用集群外部服务"><a href="#Kubernetes-Endpoints-—-使用集群外部服务" class="headerlink" title="Kubernetes Endpoints — 使用集群外部服务"></a>Kubernetes Endpoints — 使用集群外部服务</h3><p>集群内部服务也有endpoints，通过命令  <code>kubectl describe svc kubia</code> 可以看到。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">➜  k8s-in-action kubectl describe svc kubia</span><br><span class="line">Name:              kubia</span><br><span class="line">Namespace:         default</span><br><span class="line">Labels:            &lt;none&gt;</span><br><span class="line">Annotations:       kubectl.kubernetes.io/last-applied-configuration:</span><br><span class="line">                     &#123;<span class="string">"apiVersion"</span>:<span class="string">"v1"</span>,<span class="string">"kind"</span>:<span class="string">"Service"</span>,<span class="string">"metadata"</span>:&#123;<span class="string">"annotations"</span>:&#123;&#125;,<span class="string">"name"</span>:<span class="string">"kubia"</span>,<span class="string">"namespace"</span>:<span class="string">"default"</span>&#125;,<span class="string">"spec"</span>:&#123;<span class="string">"ports"</span>:[&#123;<span class="string">"port"</span>:80,<span class="string">"target...</span></span><br><span class="line"><span class="string">Selector:          app=kubia</span></span><br><span class="line"><span class="string">Type:              ClusterIP</span></span><br><span class="line"><span class="string">IP:                10.104.37.60</span></span><br><span class="line"><span class="string">Port:              &lt;unset&gt;  80/TCP</span></span><br><span class="line"><span class="string">TargetPort:        8080/TCP</span></span><br><span class="line"><span class="string">Endpoints:         172.17.0.6:8080,172.17.0.7:8080,172.17.0.8:8080</span></span><br><span class="line"><span class="string">Session Affinity:  ClientIP</span></span><br><span class="line"><span class="string">Events:            &lt;none&gt;</span></span><br></pre></td></tr></table></figure><p>手工配置的<code>endpoints</code>主要用来配置集群外部服务。</p><p>步骤如下：</p><ol><li><p>创建没有选择器的服务S</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">external-service</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  ports:</span></span><br><span class="line"><span class="attr">  - port:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure></li><li><p>为服务S创建<code>Endpoints</code>资源</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Endpoints</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">external-service</span><span class="comment"># 名称必须和服务名称相匹配</span></span><br><span class="line"><span class="attr">subsets:</span></span><br><span class="line"><span class="attr">  - addressses:</span></span><br><span class="line"><span class="attr">    - ip:</span> <span class="number">11.11</span><span class="number">.11</span><span class="number">.11</span></span><br><span class="line"><span class="attr">    - ip:</span> <span class="number">22.22</span><span class="number">.22</span><span class="number">.22</span><span class="comment"># endpoint的ip地址</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="attr">    - port:</span> <span class="number">80</span><span class="comment"># endpoint的目标端口</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="暴露服务"><a href="#暴露服务" class="headerlink" title="暴露服务"></a>暴露服务</h3><ul><li><p>NodePort方式</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">kubia-nodeport</span></span><br><span class="line"><span class="attr">spec:</span> </span><br><span class="line"><span class="attr">  type:</span> <span class="string">NodePort</span></span><br><span class="line"><span class="attr">  ports:</span></span><br><span class="line"><span class="attr">  - port:</span> <span class="number">80</span>            <span class="comment"># 暴露出去的端口</span></span><br><span class="line"><span class="attr">    targetPort:</span> <span class="number">8080</span>    <span class="comment"># 容器内部的服务端口，这里也可使用pod里ports的名字代替</span></span><br><span class="line"><span class="attr">    nodePort:</span> <span class="number">30123</span><span class="comment"># 如果不指定，将随机分配一个端口</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">kubia</span>          <span class="comment"># 标签为kubia的pod都属于这个服务</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">➜  k8s-in-action kubectl apply -f kubia-svc-nodeport.yaml</span><br><span class="line">service/kubia-nodeport created</span><br><span class="line">➜  k8s-in-action kubectl get svc</span><br><span class="line">NAME             TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)        AGE</span><br><span class="line">kubernetes       ClusterIP   10.96.0.1       &lt;none&gt;        443/TCP        11h</span><br><span class="line">kubia-nodeport   NodePort    10.104.247.31   &lt;none&gt;        80:30123/TCP   4s</span><br></pre></td></tr></table></figure><p>接下来，可以通过10.104.247.31:80, <node1>:30123, <node2>:30123去访问服务了。</p><p>minikube用户可以直接通过以下命令快速查看nodeport服务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">➜  k8s-in-action minikube service kubia-nodeport</span><br><span class="line">|-----------|----------------|-------------|---------------------------|</span><br><span class="line">| NAMESPACE |      NAME      | TARGET PORT |            URL            |</span><br><span class="line">|-----------|----------------|-------------|---------------------------|</span><br><span class="line">| default   | kubia-nodeport |             | http://192.168.64.2:30123 |</span><br><span class="line">|-----------|----------------|-------------|---------------------------|</span><br><span class="line">🎉  Opening service default/kubia-nodeport <span class="keyword">in</span> default browser...</span><br></pre></td></tr></table></figure></li><li><p>LoadBalance方式</p><p>注：minikube当前还不支持</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span> </span><br><span class="line"><span class="attr">  name:</span> <span class="string">kubia-loadbalancer</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  type:</span> <span class="string">LoadBalancer</span></span><br><span class="line"><span class="attr">  ports:</span></span><br><span class="line"><span class="attr">  - port:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">    targetPort:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">kubia</span></span><br></pre></td></tr></table></figure></li><li><p>创建Ingress资源</p><p>每个LoadBalancer都需要自己的负载均衡器以及独有的公有的IP地址，而Ingress只需要一个公网IP就能为许多服务提供访问。还可以提供基于Cookie的会话亲和性（session affinity）。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">kubia</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  rules:</span></span><br><span class="line"><span class="attr">  - host:</span> <span class="string">kubia.example.com</span>  <span class="comment">#将域名映射到服务</span></span><br><span class="line"><span class="attr">    http:</span></span><br><span class="line"><span class="attr">      paths:</span></span><br><span class="line"><span class="attr">      - path:</span> <span class="string">/</span></span><br><span class="line"><span class="attr">        backend:</span></span><br><span class="line"><span class="attr">          serviceName:</span> <span class="string">kubia-nodeport</span><span class="comment">#将所有请求发给nodeport服务的80端口</span></span><br><span class="line"><span class="attr">          servicePort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><p>测试：</p><ol><li><p>启动nodeport和rs</p></li><li><p>解析hosts</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">"<span class="variable">$(minikube ip)</span> kubia.example.com"</span> | sudo tee -a /etc/hosts</span><br></pre></td></tr></table></figure></li><li><p>访问<a href="http://kubia.example.com" target="_blank" rel="noopener">http://kubia.example.com</a></p></li></ol></li></ul><p>​       minikube必备：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开启ingress</span></span><br><span class="line">➜  minikube addons <span class="built_in">enable</span> ingress</span><br><span class="line"><span class="comment"># 执行完后看下是否下载镜像成功,下面下载失败了</span></span><br><span class="line">➜  k8s-in-action kubectl get pods -n kube-system</span><br><span class="line">NAME                                        READY   STATUS             RESTARTS   AGE</span><br><span class="line">coredns-67c766df46-6sxxr                    1/1     Running            1          12h</span><br><span class="line">coredns-67c766df46-jrmbn                    1/1     Running            1          12h</span><br><span class="line">etcd-minikube                               1/1     Running            1          12h</span><br><span class="line">kube-addon-manager-minikube                 1/1     Running            1          12h</span><br><span class="line">kube-apiserver-minikube                     1/1     Running            1          12h</span><br><span class="line">kube-controller-manager-minikube            1/1     Running            1          12h</span><br><span class="line">kube-proxy-9bxng                            1/1     Running            1          12h</span><br><span class="line">kube-scheduler-minikube                     1/1     Running            1          12h</span><br><span class="line">nginx-ingress-controller-6fc5bcc8c9-sxf25   0/1     ImagePullBackOff   0          8m45s</span><br><span class="line">storage-provisioner                         1/1     Running            1          12h</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Kubernetes集群架构&quot;&gt;&lt;a href=&quot;#Kubernetes集群架构&quot; class=&quot;headerlink&quot; title=&quot;Kubernetes集群架构&quot;&gt;&lt;/a&gt;Kubernetes集群架构&lt;/h3&gt;&lt;img src=&quot;/uploads/k8s-ar
      
    
    </summary>
    
    
      <category term="cloud native" scheme="http://www.zzzhy.cn/categories/cloud-native/"/>
    
    
      <category term="kubernetes" scheme="http://www.zzzhy.cn/tags/kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>数据库索引漫谈</title>
    <link href="http://www.zzzhy.cn/2019/10/31/database-index-surfing/"/>
    <id>http://www.zzzhy.cn/2019/10/31/database-index-surfing/</id>
    <published>2019-10-30T16:06:04.000Z</published>
    <updated>2019-11-14T16:29:21.130Z</updated>
    
    <content type="html"><![CDATA[<p>索引生成</p><p>索引与索引直接并无直接关联，他们是相互独立的。</p><ol><li><p>聚集索引</p><p> 当我们给一个数据库表分配一个主键时，这时就会生成一棵平衡树结构。这个即该表的索引树。也就是说，数据库表生来就是一颗带有数据的索引树，数据均存储在叶子节点。多达10+的分叉树结构，把大数据量搜索所需的查询次数指数级的减少，极大地降低了io消耗，从而提高性能。</p></li></ol><p><img src="https://pic2.zhimg.com/50/v2-ccc619303bf1ade411ea903f5e392941_hd.jpg" alt="“sql 聚集索引树”的图片搜索结果&quot;"></p><ol start="2"><li><p>非聚集索引</p><p> 当我们给数据库表增加普通索引、唯一索引时，这时数据库会从源表数据复制出相应的列数据出来，然后构造成一颗多叉树。同样，当匹配条件与该索引树匹配时，会迅速在叶子节点找到相应的数据。</p><p> 不一样的是，这里找到的是数据的聚集索引，然后数据库根据簇集索引找到对应的数据。所以，非聚集索引的查询最终还是会检索一遍聚集索引。</p><p><img src="https://pic1.zhimg.com/v2-ef9b5d5d6407d80b937ca19d6be9dadc_b.jpg" alt="“sql 聚集索引树”的图片搜索结果&quot;"></p></li><li><p>覆盖索引</p><p> 查询条件和返回结果直接覆盖在所查索引树内时，这样的索引叫覆盖索引。他的表现为复合索引，只不过他不需要进行回表扫描，所有的数据就在索引树内。</p>   <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select name from user where birthday &gt; '2000-01-01'\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">     id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: user</span><br><span class="line">         type: range</span><br><span class="line">possible_keys: idx_birth</span><br><span class="line">          key: idx_birth</span><br><span class="line">      key_len: 3</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: 15734</span><br><span class="line">        Extra: Using index condition</span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>   Extra 为 Using index condition 说明使用的检索方式为二级检索，即7999个书签值被用来进行回表查询。</p><p>   这句sql里查询用到2个字段，创建birthday和name的复合索引，然后再查询。</p>   <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select name from user where birthday &gt; '2000-01-01' \G</span><br><span class="line">      *************************** 1. row ***************************</span><br><span class="line">                 id: 1</span><br><span class="line">        select_type: SIMPLE</span><br><span class="line">              table: user</span><br><span class="line">               type: range</span><br><span class="line">      possible_keys: idx_birth_name, idx_birth</span><br><span class="line">                key: idx_birth_name</span><br><span class="line">            key_len: 3</span><br><span class="line">                ref: NULL</span><br><span class="line">               rows: 1684</span><br><span class="line">              Extra: Using index</span><br><span class="line">      1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>   Extra提示信息为Using index而不是Using index condition，代表没有了回表查询的过程，也就是实现了索引覆盖。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;索引生成&lt;/p&gt;
&lt;p&gt;索引与索引直接并无直接关联，他们是相互独立的。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;聚集索引&lt;/p&gt;
&lt;p&gt; 当我们给一个数据库表分配一个主键时，这时就会生成一棵平衡树结构。这个即该表的索引树。也就是说，数据库表生来就是一颗带有数据的索引树，数据均存储在
      
    
    </summary>
    
    
      <category term="database" scheme="http://www.zzzhy.cn/categories/database/"/>
    
    
      <category term="database" scheme="http://www.zzzhy.cn/tags/database/"/>
    
      <category term="sql" scheme="http://www.zzzhy.cn/tags/sql/"/>
    
  </entry>
  
  <entry>
    <title>nginx编译参数</title>
    <link href="http://www.zzzhy.cn/2019/10/30/nginx-compile-opts/"/>
    <id>http://www.zzzhy.cn/2019/10/30/nginx-compile-opts/</id>
    <published>2019-10-29T17:39:52.000Z</published>
    <updated>2019-11-14T16:30:02.660Z</updated>
    
    <content type="html"><![CDATA[<h1 id="nginx参数："><a href="#nginx参数：" class="headerlink" title="nginx参数："></a>nginx参数：</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">–prefix= 指向安装目录</span><br><span class="line">–sbin-path 指向（执行）程序文件（nginx）</span><br><span class="line">–conf-path= 指向配置文件（nginx.conf）</span><br><span class="line">–error-log-path= 指向错误日志目录</span><br><span class="line">–pid-path= 指向pid文件（nginx.pid）</span><br><span class="line">–lock-path= 指向lock文件（nginx.lock）（安装文件锁定，防止安装文件被别人利用，或自己误操作。）</span><br><span class="line">–user= 指定程序运行时的非特权用户</span><br><span class="line">–group= 指定程序运行时的非特权用户组</span><br><span class="line">–builddir= 指向编译目录</span><br><span class="line">–with-rtsig_module 启用rtsig模块支持（实时信号）</span><br><span class="line">–with-select_module 启用select模块支持（一种轮询模式,不推荐在高载环境下使用）禁用：–without-select_module</span><br><span class="line">–with-poll_module 启用poll模块支持（功能与select相同，与select特性相同，为一种轮询模式,不推荐在高载环境下使用）</span><br><span class="line">–with-file-aio 启用file aio支持（一种APL文件传输格式）</span><br><span class="line">–with-ipv6 启用ipv6支持</span><br><span class="line">–with-http_ssl_module 启用ngx_http_ssl_module支持（使支持https请求，需已安装openssl）</span><br><span class="line">–with-http_realip_module 启用ngx_http_realip_module支持（这个模块允许从请求标头更改客户端的IP地址值，默认为关）</span><br><span class="line">–with-http_addition_module 启用ngx_http_addition_module支持（作为一个输出过滤器，支持不完全缓冲，分部分响应请求）</span><br><span class="line">–with-http_xslt_module 启用ngx_http_xslt_module支持（过滤转换XML请求）</span><br><span class="line">–with-http_image_filter_module 启用ngx_http_image_filter_module支持（传输JPEG/GIF/PNG 图片的一个过滤器）（默认为不启用。gd库要用到）</span><br><span class="line">–with-http_geoip_module 启用ngx_http_geoip_module支持（该模块创建基于与MaxMind GeoIP二进制文件相配的客户端IP地址的ngx_http_geoip_module变量）</span><br><span class="line">–with-http_sub_module 启用ngx_http_sub_module支持（允许用一些其他文本替换nginx响应中的一些文本）</span><br><span class="line">–with-http_dav_module 启用ngx_http_dav_module支持（增加PUT,DELETE,MKCOL：创建集合,COPY和MOVE方法）默认情况下为关闭，需编译开启</span><br><span class="line">–with-http_flv_module 启用ngx_http_flv_module支持（提供寻求内存使用基于时间的偏移量文件）</span><br><span class="line">–with-http_gzip_static_module 启用ngx_http_gzip_static_module支持（在线实时压缩输出数据流）</span><br><span class="line">–with-http_random_index_module 启用ngx_http_random_index_module支持（从目录中随机挑选一个目录索引）</span><br><span class="line">–with-http_secure_link_module 启用ngx_http_secure_link_module支持（计算和检查要求所需的安全链接网址）</span><br><span class="line">–with-http_degradation_module  启用ngx_http_degradation_module支持（允许在内存不足的情况下返回204或444码）</span><br><span class="line">–with-http_stub_status_module 启用ngx_http_stub_status_module支持（获取nginx自上次启动以来的工作状态）</span><br><span class="line">–without-http_charset_module 禁用ngx_http_charset_module支持（重新编码web页面，但只能是一个方向–服务器端到客户端，并且只有一个字节的编码可以被重新编码）</span><br><span class="line">–without-http_gzip_module 禁用ngx_http_gzip_module支持（该模块同-with-http_gzip_static_module功能一样）</span><br><span class="line">–without-http_ssi_module 禁用ngx_http_ssi_module支持（该模块提供了一个在输入端处理处理服务器包含文件（SSI）的过滤器，目前支持SSI命令的列表是不完整的）</span><br><span class="line">–without-http_userid_module 禁用ngx_http_userid_module支持（该模块用来处理用来确定客户端后续请求的cookies）</span><br><span class="line">–without-http_access_module 禁用ngx_http_access_module支持（该模块提供了一个简单的基于主机的访问控制。允许/拒绝基于ip地址）</span><br><span class="line">–without-http_auth_basic_module禁用ngx_http_auth_basic_module（该模块是可以使用用户名和密码基于http基本认证方法来保护你的站点或其部分内容）</span><br><span class="line">–without-http_autoindex_module 禁用<span class="built_in">disable</span> ngx_http_autoindex_module支持（该模块用于自动生成目录列表，只在ngx_http_index_module模块未找到索引文件时发出请求。）</span><br><span class="line">–without-http_geo_module 禁用ngx_http_geo_module支持（创建一些变量，其值依赖于客户端的IP地址）</span><br><span class="line">–without-http_map_module 禁用ngx_http_map_module支持（使用任意的键/值对设置配置变量）</span><br><span class="line">–without-http_split_clients_module 禁用ngx_http_split_clients_module支持（该模块用来基于某些条件划分用户。条件如：ip地址、报头、cookies等等）</span><br><span class="line">–without-http_referer_module 禁用<span class="built_in">disable</span> ngx_http_referer_module支持（该模块用来过滤请求，拒绝报头中Referer值不正确的请求）</span><br><span class="line">–without-http_rewrite_module 禁用ngx_http_rewrite_module支持（该模块允许使用正则表达式改变URI，并且根据变量来转向以及选择配置。如果在server级别设置该选项，那么他们将在 location之前生效。如果在location还有更进一步的重写规则，location部分的规则依然会被执行。如果这个URI重写是因为location部分的规则造成的，那么 location部分会再次被执行作为新的URI。 这个循环会执行10次，然后Nginx会返回一个500错误。）</span><br><span class="line">–without-http_proxy_module 禁用ngx_http_proxy_module支持（有关代理服务器）</span><br><span class="line">–without-http_fastcgi_module 禁用ngx_http_fastcgi_module支持（该模块允许Nginx 与FastCGI 进程交互，并通过传递参数来控制FastCGI 进程工作。 ）FastCGI一个常驻型的公共网关接口。</span><br><span class="line">–without-http_uwsgi_module 禁用ngx_http_uwsgi_module支持（该模块用来医用uwsgi协议，uWSGI服务器相关）</span><br><span class="line">–without-http_scgi_module 禁用ngx_http_scgi_module支持（该模块用来启用SCGI协议支持，SCGI协议是CGI协议的替代。它是一种应用程序与HTTP服务接口标准。它有些像FastCGI但他的设计 更容易实现。）</span><br><span class="line">–without-http_memcached_module 禁用ngx_http_memcached_module支持（该模块用来提供简单的缓存，以提高系统效率）</span><br><span class="line">-without-http_limit_zone_module 禁用ngx_http_limit_zone_module支持（该模块可以针对条件，进行会话的并发连接数控制）</span><br><span class="line">–without-http_limit_req_module 禁用ngx_http_limit_req_module支持（该模块允许你对于一个地址进行请求数量的限制用一个给定的session或一个特定的事件）</span><br><span class="line">–without-http_empty_gif_module 禁用ngx_http_empty_gif_module支持（该模块在内存中常驻了一个1*1的透明GIF图像，可以被非常快速的调用）</span><br><span class="line">–without-http_browser_module 禁用ngx_http_browser_module支持（该模块用来创建依赖于请求报头的值。如果浏览器为modern ，则<span class="variable">$modern_browser</span>等于modern_browser_value指令分配的值；如 果浏览器为old，则<span class="variable">$ancient_browser</span>等于 ancient_browser_value指令分配的值；如果浏览器为 MSIE中的任意版本，则 <span class="variable">$msie</span>等于1）</span><br><span class="line">–without-http_upstream_ip_hash_module 禁用ngx_http_upstream_ip_hash_module支持（该模块用于简单的负载均衡）</span><br><span class="line">–with-http_perl_module 启用ngx_http_perl_module支持（该模块使nginx可以直接使用perl或通过ssi调用perl）</span><br><span class="line">–with-perl_modules_path= 设定perl模块路径</span><br><span class="line">–with-perl= 设定perl库文件路径</span><br><span class="line">–http-log-path= 设定access <span class="built_in">log</span>路径</span><br><span class="line">–http-client-body-temp-path= 设定http客户端请求临时文件路径</span><br><span class="line">–http-proxy-temp-path= 设定http代理临时文件路径</span><br><span class="line">–http-fastcgi-temp-path= 设定http fastcgi临时文件路径</span><br><span class="line">–http-uwsgi-temp-path= 设定http uwsgi临时文件路径</span><br><span class="line">–http-scgi-temp-path= 设定http scgi临时文件路径</span><br><span class="line">-without-http 禁用http server功能</span><br><span class="line">–without-http-cache 禁用http cache功能</span><br><span class="line">–with-mail 启用POP3/IMAP4/SMTP代理模块支持</span><br><span class="line">–with-mail_ssl_module 启用ngx_mail_ssl_module支持</span><br><span class="line">–without-mail_pop3_module 禁用pop3协议（POP3即邮局协议的第3个版本,它是规定个人计算机如何连接到互联网上的邮件服务器进行收发邮件的协议。是因特网电子邮件的第一个离线协议标 准,POP3协议允许用户从服务器上把邮件存储到本地主机上,同时根据客户端的操作删除或保存在邮件服务器上的邮件。POP3协议是TCP/IP协议族中的一员，主要用于 支持使用客户端远程管理在服务器上的电子邮件）</span><br><span class="line">–without-mail_imap_module 禁用imap协议（一种邮件获取协议。它的主要作用是邮件客户端可以通过这种协议从邮件服务器上获取邮件的信息，下载邮件等。IMAP协议运行在TCP/IP协议之上， 使用的端口是143。它与POP3协议的主要区别是用户可以不用把所有的邮件全部下载，可以通过客户端直接对服务器上的邮件进行操作。）</span><br><span class="line">–without-mail_smtp_module 禁用smtp协议（SMTP即简单邮件传输协议,它是一组用于由源地址到目的地址传送邮件的规则，由它来控制信件的中转方式。SMTP协议属于TCP/IP协议族，它帮助每台计算机在发送或中转信件时找到下一个目的地。）</span><br><span class="line">–with-google_perftools_module 启用ngx_google_perftools_module支持（调试用，剖析程序性能瓶颈）</span><br><span class="line">–with-cpp_test_module 启用ngx_cpp_test_module支持</span><br><span class="line">–add-module= 启用外部模块支持</span><br><span class="line">–with-cc= 指向C编译器路径</span><br><span class="line">–with-cpp= 指向C预处理路径</span><br><span class="line">–with-cc-opt= 设置C编译器参数（PCRE库，需要指定–with-cc-opt=”-I /usr/<span class="built_in">local</span>/include”，如果使用select()函数则需要同时增加文件描述符数量，可以通过–with-cc- opt=”-D FD_SETSIZE=2048”指定。）</span><br><span class="line">–with-ld-opt= 设置连接文件参数。（PCRE库，需要指定–with-ld-opt=”-L /usr/<span class="built_in">local</span>/lib”。）</span><br><span class="line">–with-cpu-opt= 指定编译的CPU，可用的值为: pentium, pentiumpro, pentium3, pentium4, athlon, opteron, amd64, sparc32, sparc64, ppc64</span><br><span class="line">–without-pcre 禁用pcre库</span><br><span class="line">–with-pcre 启用pcre库</span><br><span class="line">–with-pcre= 指向pcre库文件目录</span><br><span class="line">–with-pcre-opt= 在编译时为pcre库设置附加参数</span><br><span class="line">–with-md5= 指向md5库文件目录（消息摘要算法第五版，用以提供消息的完整性保护）</span><br><span class="line">–with-md5-opt= 在编译时为md5库设置附加参数</span><br><span class="line">–with-md5-asm 使用md5汇编源</span><br><span class="line">–with-sha1= 指向sha1库目录（数字签名算法，主要用于数字签名）</span><br><span class="line">–with-sha1-opt= 在编译时为sha1库设置附加参数</span><br><span class="line">–with-sha1-asm 使用sha1汇编源</span><br><span class="line">–with-zlib= 指向zlib库目录</span><br><span class="line">–with-zlib-opt= 在编译时为zlib设置附加参数</span><br><span class="line">–with-zlib-asm= 为指定的CPU使用zlib汇编源进行优化，CPU类型为pentium, pentiumpro</span><br><span class="line">–with-libatomic 为原子内存的更新操作的实现提供一个架构</span><br><span class="line">–with-libatomic= 指向libatomic_ops安装目录</span><br><span class="line">–with-openssl= 指向openssl安装目录</span><br><span class="line">–with-openssl-opt 在编译时为openssl设置附加参数</span><br><span class="line">–with-debug 启用debug日志</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;nginx参数：&quot;&gt;&lt;a href=&quot;#nginx参数：&quot; class=&quot;headerlink&quot; title=&quot;nginx参数：&quot;&gt;&lt;/a&gt;nginx参数：&lt;/h1&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td cla
      
    
    </summary>
    
    
      <category term="nginx" scheme="http://www.zzzhy.cn/categories/nginx/"/>
    
    
      <category term="nginx" scheme="http://www.zzzhy.cn/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>sql tuning</title>
    <link href="http://www.zzzhy.cn/2019/10/30/sql-tuning/"/>
    <id>http://www.zzzhy.cn/2019/10/30/sql-tuning/</id>
    <published>2019-10-29T17:20:51.000Z</published>
    <updated>2019-11-14T16:32:24.018Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><ol><li>对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。</li><li>应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，<br>Sql 代码 : select id from t where num is null;<br>可以在 num 上设置默认值 0,确保表中 num 列没有 null 值，然后这样查询：<br>Sql 代码 : select id from t where num=0;</li><li>应尽量避免在 where 子句中使用!=或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描。</li><li>应尽量避免在 where 子句中使用 or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，<br>Sql 代码 : select id from t where num=10 or num=20;<br>可以这样查询：<br>Sql 代码 : select id from t where num=10 union all select id from t where num=20;</li><li>in 和 not in 也要慎用，否则会导致全表扫描，如：<br>Sql 代码 : select id from t where num in(1,2,3);<br>对于连续的数值，能用 between 就不要用 in 了：<br>Sql 代码 : select id from t where num between 1 and 3;</li><li>下面的查询也将导致全表扫描：<br>Sql 代码 : select id from t where name like ‘%c%’;<br>若要提高效率，可以考虑全文检索。</li><li>如果在 where 子句中使用参数，也会导致全表扫描。因为 SQL 只有在运行时才会解析局部变量，但优 化程序不能将访问计划的选择推迟到运行时;它必须在编译时进行选择。然 而，如果在编译时建立访问计 划，变量的值还是未知的，因而无法作为索引选择的输入项。如下面语句将进行全表扫描：<br>Sql 代码 : select id from t where num=@num ;<br>可以改为强制查询使用索引：<br>Sql 代码 : select id from t with(index(索引名)) where num=@num ;</li><li>应尽量避免在 where 子句中对字段进行表达式操作， 这将导致引擎放弃使用索引而进行全表扫描。<br>Sql 代码 : select id from t where num/2=100;<br>可以这样查询：<br>Sql 代码 : select id from t where num=100*2;</li><li>应尽量避免在 where 子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。如：<br>Sql 代码 : select id from t where substring(name,1,3)=’abc’;#name 以 abc 开头的 id<br>应改为：<br>Sql 代码 : select id from t where name like ‘abc%’;</li><li>不要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用 索引。</li><li>在使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索引中的第一个字段作为条件 时才能保证系统使用该索引， 否则该索引将不会 被使用， 并且应尽可能的让字段顺序与索引顺序相一致。</li><li>不要写一些没有意义的查询，如需要生成一个空表结构：<br>Sql 代码 : select col1,col2 into #t from t where 1=0;<br>这类代码不会返回任何结果集，但是会消耗系统资源的，应改成这样：<br>Sql 代码 : create table #t(…);</li><li>很多时候用 exists 代替 in 是一个好的选择：<br>Sql 代码 : select num from a where num in(select num from b);<br>用下面的语句替换：<br>Sql 代码 : select num from a where exists(select 1 from b where num=a.num);</li><li>并不是所有索引对查询都有效，SQL 是根据表中数据来进行查询优化的，当索引列有大量数据重复时， SQL 查询可能不会去利用索引，如一表中有字段 <strong>*,male、female 几乎各一半，那么即使在 *</strong> 上建 了索引也对查询效率起不了作用。</li><li>索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。一个表的索引数最好不要超过 6 个，若太多则应考虑一些不常使用到的列上建的索引是否有必要。</li><li>应尽可能的避免更新 clustered 索引数据列， 因为 clustered 索引数据列的顺序就是表记录的物理存储顺序，一旦该列值改变将导致整个表记录的顺序的调整，会耗费相当大的资源。若应用系统需要频繁更新 clustered 索引数据列，那么需要考虑是否应将该索引建为 clustered 索引。</li><li>尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并 会增加存储开销。这是因为引擎在处理查询和连接时会逐个比较字符串中每一个字符，而对于数字型而言 只需要比较一次就够了。</li><li>尽可能的使用 varchar/nvarchar 代替 char/nchar , 因为首先变长字段存储空间小， 可以节省存储空间， 其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。</li><li>任何地方都不要使用 select * from t ,用具体的字段列表代替“*”,不要返回用不到的任何字段。</li><li>尽量使用表变量来代替临时表。如果表变量包含大量数据，请注意索引非常有限(只有主键索引)。</li><li>避免频繁创建和删除临时表，以减少系统表资源的消耗。</li><li>临时表并不是不可使用，适当地使用它们可以使某些例程更有效，例如，当需要重复引用大型表或常用 表中的某个数据集时。但是，对于一次性事件， 最好使用导出表。</li><li>在新建临时表时，如果一次性插入数据量很大，那么可以使用 select into 代替 create table,避免造成大量 log ,以提高速度;如果数据量不大，为了缓和系统表的资源，应先 create table,然后 insert.</li><li>如果使用到了临时表， 在存储过程的最后务必将所有的临时表显式删除， 先 truncate table ,然后 drop table ,这样可以避免系统表的较长时间锁定。</li><li>尽量避免使用游标，因为游标的效率较差，如果游标操作的数据超过 1 万行，那么就应该考虑改写。</li><li>使用基于游标的方法或临时表方法之前，应先寻找基于集的解决方案来解决问题，基于集的方法通常更 有效。</li><li>与临时表一样，游标并不是不可使用。对小型数据集使用 FAST_FORWARD 游标通常要优于其他逐行处理方法，尤其是在必须引用几个表才能获得所需的数据时。在结果集中包括“合计”的例程通常要比使用游标执行的速度快。如果开发时间允许，基于游标的方法和基于集的方法都可以尝试一下，看哪一种方法的效果更好。</li><li>在所有的存储过程和触发器的开始处设置 SET NOCOUNT ON ,在结束时设置 SET NOCOUNT OFF .无需在执行存储过程和触发器的每个语句后向客户端发送 DONE_IN_PROC 消息。</li><li>尽量避免大事务操作，提高系统并发能力。 sql 优化方法使用索引来更快地遍历表。 缺省情况下建立的索引是非群集索引，但有时它并不是最佳的。在非群集索引下，数据在物理上随机存放在数据页上。合理的索引设计要建立在对各种查询的分析和预测上。一般来说：<br>a.有大量重复值、且经常有范围查询( &gt; ,&lt; ,&gt; =,&lt; =)和 order by、group by 发生的列，可考虑建立集群索引;<br>b.经常同时存取多列，且每列都含有重复值可考虑建立组合索引;<br>c.组合索引要尽量使关键查询形成索引覆盖，其前导列一定是使用最频繁的列。索引虽有助于提高性能但 不是索引越多越好，恰好相反过多的索引会导致系统低效。用户在表中每加进一个索引，维护索引集合就 要做相应的更新工作。</li><li>定期分析表和检查表。<br>分析表的语法：ANALYZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tb1_name[, tbl_name]…<br>以上语句用于分析和存储表的关键字分布，分析的结果将可以使得系统得到准确的统计信息，使得SQL能够生成正确的执行计划。如果用户感觉实际执行计划并不是预期的执行计划，执行一次分析表可能会解决问题。在分析期间，使用一个读取锁定对表进行锁定。这对于MyISAM，DBD和InnoDB表有作用。<br>例如分析一个数据表：analyze table table_name<br>检查表的语法：CHECK TABLE tb1_name[,tbl_name]…[option]…option = {QUICK | FAST | MEDIUM | EXTENDED | CHANGED}<br>检查表的作用是检查一个或多个表是否有错误，CHECK TABLE 对MyISAM 和 InnoDB表有作用，对于MyISAM表，关键字统计数据被更新<br>CHECK TABLE 也可以检查视图是否有错误，比如在视图定义中被引用的表不存在。</li><li>定期优化表。<br>优化表的语法：OPTIMIZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tb1_name [,tbl_name]…<br>如果删除了表的一大部分，或者如果已经对含有可变长度行的表(含有 VARCHAR、BLOB或TEXT列的表)进行更多更改，则应使用OPTIMIZE TABLE命令来进行表优化。这个命令可以将表中的空间碎片进行合并，并且可以消除由于删除或者更新造成的空间浪费，但OPTIMIZE TABLE 命令只对MyISAM、 BDB 和InnoDB表起作用。<br>例如： optimize table table_name<br>注意： analyze、check、optimize执行期间将对表进行锁定，因此一定注意要在MySQL数据库不繁忙的时候执行相关的操作。</li></ol><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><ol><li>在海量查询时尽量少用格式转换。</li><li>ORDER BY 和 GROPU BY:使用 ORDER BY 和 GROUP BY 短语，任何一种索引都有助于 SELECT 的性能提高。</li><li>任何对列的操作都将导致表扫描，它包括数据库教程函数、计算表达式等等，查询时要尽可能将操作移 至等号右边。</li><li>IN、OR 子句常会使用工作表，使索引失效。如果不产生大量重复值，可以考虑把子句拆开。拆开的子 句中应该包含索引。</li><li>只要能满足你的需求，应尽可能使用更小的数据类型：例如使用 MEDIUMINT 代替 INT</li><li>尽量把所有的列设置为 NOT NULL,如果你要保存 NULL,手动去设置它，而不是把它设为默认值。</li><li>尽量少用 VARCHAR、TEXT、BLOB 类型</li><li>如果你的数据只有你所知的少量的几个。最好使用 ENUM 类型</li><li>正如 graymice 所讲的那样，建立索引。</li><li>合理用运分表与分区表提高数据存放和提取速度。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;基础&quot;&gt;&lt;a href=&quot;#基础&quot; class=&quot;headerlink&quot; title=&quot;基础&quot;&gt;&lt;/a&gt;基础&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。&lt;/li&gt;
&lt;li&gt;应尽
      
    
    </summary>
    
    
      <category term="sql" scheme="http://www.zzzhy.cn/categories/sql/"/>
    
    
      <category term="tuning" scheme="http://www.zzzhy.cn/tags/tuning/"/>
    
      <category term="sql" scheme="http://www.zzzhy.cn/tags/sql/"/>
    
  </entry>
  
  <entry>
    <title>akka best practice</title>
    <link href="http://www.zzzhy.cn/2019/10/30/akka-best-practice/"/>
    <id>http://www.zzzhy.cn/2019/10/30/akka-best-practice/</id>
    <published>2019-10-29T17:12:36.000Z</published>
    <updated>2019-11-14T16:28:41.979Z</updated>
    
    <content type="html"><![CDATA[<ul><li>使用tell而非ask，ExtraActor模式</li><li>使用dispatcher隔离耗时阻塞任务，区分不同的任务类别使用不同线程数量的线程池</li><li>一般来说ForkJoinPool的效率最高</li><li>使用router来进行多核编程，BalancePool适用于本地，所有actor共用一个邮箱</li><li>包含状态的可以使用become/unbecome来进行编程，使状态清晰，代码逻辑结构简单</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;使用tell而非ask，ExtraActor模式&lt;/li&gt;
&lt;li&gt;使用dispatcher隔离耗时阻塞任务，区分不同的任务类别使用不同线程数量的线程池&lt;/li&gt;
&lt;li&gt;一般来说ForkJoinPool的效率最高&lt;/li&gt;
&lt;li&gt;使用router来进行多核编
      
    
    </summary>
    
    
      <category term="akka" scheme="http://www.zzzhy.cn/categories/akka/"/>
    
    
      <category term="akka" scheme="http://www.zzzhy.cn/tags/akka/"/>
    
      <category term="actor" scheme="http://www.zzzhy.cn/tags/actor/"/>
    
      <category term="tuning" scheme="http://www.zzzhy.cn/tags/tuning/"/>
    
  </entry>
  
  <entry>
    <title>spark streaming入门</title>
    <link href="http://www.zzzhy.cn/2019/10/30/spark-streaming-indoor/"/>
    <id>http://www.zzzhy.cn/2019/10/30/spark-streaming-indoor/</id>
    <published>2019-10-29T16:31:45.000Z</published>
    <updated>2019-11-14T16:31:28.903Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 构建一个 Spark Streaming 应用程序的4 个步骤</span></span><br><span class="line">scala&gt; val ssc = new StreamingContext(sc,Seconds(5))</span><br><span class="line"></span><br><span class="line">scala&gt; val lines = ssc.socketTextStream(<span class="string">"localhost"</span>,9999)</span><br><span class="line"></span><br><span class="line">scala&gt; val words = lines.flatMap(_.split(<span class="string">" "</span>))</span><br><span class="line"></span><br><span class="line">scala&gt; val pairs = words.map(word =&gt; (word,1))</span><br><span class="line"></span><br><span class="line">scala&gt; val wordCounts = pairs.reduceByKey(_+_)</span><br><span class="line"></span><br><span class="line">scala&gt; wordCounts.print()</span><br><span class="line"></span><br><span class="line">scala&gt; ssc.start()</span><br></pre></td></tr></table></figure><h2 id="构建-Streaming-Context-对象"><a href="#构建-Streaming-Context-对象" class="headerlink" title="构建 Streaming Context 对象"></a>构建 Streaming Context 对象</h2><blockquote><p>使用 Spark Streaming 需要创建 StreamingContext 对象。Spark Streaming 需要制定处理数据的时间间隔，如 1s，那么 Spark Streaming 会以1s为时间窗口进行数据处理。此参数需要根据用户的需求和集群的处理能力进行适当的设置，它的生命周期会伴随整个StreamingContext 的生命周期且无法重新设置。因此，用户需要从需求和集群处理能力出发，设置一个合理的时间间隔。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SparkConf sparkConf = <span class="keyword">new</span> SparkConf().setAppName(<span class="string">"JavaRecoverableNetworkWordCount"</span>);</span><br><span class="line"> <span class="comment">// Create the context with a 1 second batch size</span></span><br><span class="line"> <span class="comment">//首先通过 JavaStreamingContextFactory 创建 Spark Streaming 过程。</span></span><br><span class="line"> JavaStreamingContext ssc = <span class="keyword">new</span> JavaStreamingContext(sparkConf, Durations.seconds(<span class="number">1</span>));</span><br><span class="line"> ssc.checkpoint(checkpointDirectory);</span><br></pre></td></tr></table></figure><blockquote><p>Spark Streaming 有特定的窗口操作，窗口操作涉及两个参数：一个是滑动窗口的宽度（Window Duration）；另一个是窗口滑动的频率（Slide Duration），这两个参数必须是 batch size 的倍数。例如以过去 5 秒钟为一个输入窗口，每 1 秒统计一下 WordCount，那么我们会将过去 5 秒钟的每一秒钟的 WordCount 都进行统计，然后进行叠加，得出这个窗口中的单词统计。</p></blockquote><h2 id="创建-InputDStream"><a href="#创建-InputDStream" class="headerlink" title="创建 InputDStream"></a>创建 InputDStream</h2><blockquote><p>如同 Strom 的 Spout 一样，Spark Streaming 需要指明数据源。例如 socketTextStream，Spark Streaming 将以套接字连接作为数据源读取数据。当然，Spark Streaming 支持多种不同的数据源，包括 kafkaStream、flumeStream、fileStream、networkStream 等。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JavaReceiverInputDStream&lt;<span class="built_in">String</span>&gt; lines = ssc.socketTextStream(ip, port);</span><br></pre></td></tr></table></figure><h2 id="操作-DStream"><a href="#操作-DStream" class="headerlink" title="操作 DStream"></a>操作 DStream</h2><blockquote><p>对于从数据源得到的DStream，用户可以在其基础上进行各种操作，如 WordCount 的操作就是一个典型的单词计数执行流程，即对当前时间窗口内从数据源得到的数据进行分词，然后利用 MapReduce 算法映射和计算，最后使用 print() 输出结果。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">JavaDStream&lt;<span class="built_in">String</span>&gt; words = lines.flatMap(s -&gt; Lists.newArrayList(SPACE.split(s)));</span><br><span class="line"> JavaPairDStream&lt;<span class="built_in">String</span>, Integer&gt; wordCounts = words.mapToPair(w -&gt; <span class="keyword">new</span> Tuple2&lt;<span class="built_in">String</span>, Integer&gt;(w, <span class="number">1</span>)).reduceByKey((a,b)-&gt;a+b);</span><br><span class="line"></span><br><span class="line"> wordCounts.foreachRDD((rdd,time) -&gt; &#123;</span><br><span class="line">    <span class="built_in">String</span> counts = <span class="string">"Counts at time "</span> + time + <span class="string">" "</span> + rdd.collect();</span><br><span class="line">    System.out.println(counts);</span><br><span class="line">    System.out.println(<span class="string">"Appending to "</span> + outputFile.getAbsolutePath());</span><br><span class="line">    Files.append(counts + <span class="string">"\n"</span>, outputFile, Charset.defaultCharset());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure><h2 id="启动-Spark-Streaming"><a href="#启动-Spark-Streaming" class="headerlink" title="启动 Spark Streaming"></a>启动 Spark Streaming</h2><blockquote><p>之前的所有步骤只创建了执行流程，程序没有有真正连接上数据源，也没有对数据进行任何操作，只是设定好了所有的执行计算，当 ssc.start() 启动后，程序才真正进行所有预期的操作。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssc.start();</span><br><span class="line">ssc.awaitTermination();</span><br></pre></td></tr></table></figure><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol><li>Spark Streaming 内部的实现和调度方式高度依赖 Spark 的 DAG 调度器和 RDD，这就决定了 Spark Streaming 的设计初衷必须是粗粒度方式的，同时，由于 Spark 内部调度器足够快速和高效，可以快速地处理小批量数据，这就获得准实时的特性。</li><li>Spark Streaming 的粗粒度执行方式使其确保“处理且仅处理一次”的特性，同时也可以更方便地实现容错恢复机制。</li><li>由于 Spark Streaming 的 DStream 本质是 RDD 在流式数据上的抽象，因此基于 RDD 的各种操作也有相应的基于 DStream 的版本，这样就大大降低了用户对于新框架的学习成本，在了解 Spark 的情况下用户将很容易使用 Spark Streaming。</li><li>由于 DStream 是在 RDD 上的抽象，那么也就更容易与 RDD 进行交互操作，在需要将流式数据和批处理数据结合进行分析的情况下，将会变得非常方便。</li></ol><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ol><li>Spark Streaming 的粗粒度处理方式也造成了不可避免的延迟。在细粒度处理方式下，理想情况下每一条记录都会被实时处理，而在 Spark Streaming 中，数据需要汇总到一定的量后再一次性处理，这就增加了数据处理的延迟，这种延迟是由框架的设计引入的，并不是由网络或其他情况造成的。</li><li>Spark Streaming 当前版本稳定性不是很好。<br>总而言之，Spark Streaming 为我们提供了一种崭新的流式处理框架，相信未来随着 Spark Streaming 会在易用性、稳定性以及其他方面有很大的提升。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=
      
    
    </summary>
    
    
      <category term="spark" scheme="http://www.zzzhy.cn/categories/spark/"/>
    
    
      <category term="scala" scheme="http://www.zzzhy.cn/tags/scala/"/>
    
      <category term="spark" scheme="http://www.zzzhy.cn/tags/spark/"/>
    
      <category term="spark streaming" scheme="http://www.zzzhy.cn/tags/spark-streaming/"/>
    
  </entry>
  
  <entry>
    <title>spark streaming 基础与调优</title>
    <link href="http://www.zzzhy.cn/2019/10/30/spark-streaming-tuning/"/>
    <id>http://www.zzzhy.cn/2019/10/30/spark-streaming-tuning/</id>
    <published>2019-10-29T16:27:23.000Z</published>
    <updated>2019-11-14T16:31:57.795Z</updated>
    
    <content type="html"><![CDATA[<h2 id="spark-streaming的状态更新"><a href="#spark-streaming的状态更新" class="headerlink" title="spark-streaming的状态更新"></a>spark-streaming的状态更新</h2><p>updateStateByKey、reduceByKeyAndWindow<br><strong>必须启用检查点功能，因为有状态的操作是从程序开始时一直进行的</strong></p><h2 id="DStream操作"><a href="#DStream操作" class="headerlink" title="DStream操作"></a>DStream操作</h2><ul><li>与RDD相同的操作方法</li><li>transform：用于直接操作DStream内部的RDD，那些DStream没有提供的RDD操作，可以通过transform调用实现。如join：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val joinedDStream = d.transform(<span class="function"><span class="params">rdd</span> =&gt;</span> &#123;</span><br><span class="line">    rdd.join(rdd2)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><h3 id="窗口操作"><a href="#窗口操作" class="headerlink" title="窗口操作"></a>窗口操作</h3><ul><li>窗口长度<blockquote><p>窗口跨越的周期次数，每次窗口处理的数据分片数</p></blockquote></li><li>滑动区间<blockquote><p>从当前窗口到下一个窗口间隔的周期数量,每次划过的窗口数<br>如果这两个参数的值都是1，则跟不使用窗口效果一样。每个窗口的周期数据都会合并成一个RDD保存在DStream中。</p></blockquote></li><li>窗口函数<br>用windowLength、slideInterval生成一个带窗口的DStream，也可以使用加窗口参数的方法：countByWindow、reduceByWindow、reduceByKeyAndWindow、countByValueAndWindow.</li></ul><h3 id="高级操作"><a href="#高级操作" class="headerlink" title="高级操作"></a>高级操作</h3><ol><li><p>缓存与持久化<br>窗口函数和updateStateByKey会默认自动持久化<br>从网络接收数据的输入DStream，默认持久化级别是复制数据到两个节点上，以确保容错能力。</p></li><li><p>打包、发布和监控</p></li></ol><ul><li>需要提供spark之外的其他所有第三方jar包。</li><li>最好用hdfs或s3的文件系统目录来配置检查点</li><li>配置driver程序自动重启<blockquote><p>standalone模式提交用–deploy-mode cluster –supervise,YARN下选择yarn-cluster，Mesos下通过Marathon协助实现。</p></blockquote></li><li>从1.2开始，支持Write Ahead Logs(WAL)，开启之后，所有收到的数据在处理前会写到检查点目录下，可确保driver重启期间数据不丢失。设置spark.streaming.receiver.writeAheadLog.enable为true开启，会降低数据接收的吞吐量，不过可以通过采用<strong>并发接收</strong>的方式降低影响。如果开启了WAL，可以关闭接受数据时的复制机制：<strong>设置输入DStream的存储级别为StorageLevel.MEMORY_AND_DISK_SER</strong>。</li></ul><ol start="3"><li>更新程序代码<br>为了不丢失数据，可采用一下两种方法：</li></ol><ul><li><strong>新旧程序同时运行。</strong> 等新的程序运行之后，在停止旧的程序。这种方式要求数据源支持同时向新、旧两个版本的程序发数据</li><li><strong>先停止旧的程序再启动新的程序。</strong><br>要保证旧的程序是被优雅的关闭，确保关闭前接收到的数据都处理完了。这种方式只适用于<strong>支持缓存数据功能</strong>的数据源，如Kafka、Flume。启动新的程序时在读取前一个程序的检查点信息时可能出错，因为检查点中一些对象是序列化存储，新的对象结构可能已经改变了。解决办法是：<strong>用新的检查点目录</strong>或者<strong>删除旧的检查点目录下的所有内容</strong>。</li></ul><h2 id="spark-streaming调优方向"><a href="#spark-streaming调优方向" class="headerlink" title="spark streaming调优方向"></a>spark streaming调优方向</h2><ol><li><p>每个批次的处理时间尽可能短</p></li><li><p>收到数据后尽可能快的处理</p></li></ol><h2 id="优化方法"><a href="#优化方法" class="headerlink" title="优化方法"></a>优化方法</h2><h3 id="减少批处理的时间"><a href="#减少批处理的时间" class="headerlink" title="减少批处理的时间"></a>减少批处理的时间</h3><ol><li>增加数据接收的并发数量，尤其当瓶颈发生在数据接收的时候。<blockquote><p>默认每个InputDStream只会创建一个接收器，我们可以创建多个让它们接收不同的数据分区，以实现并行接收。</p></blockquote></li></ol><blockquote><p>比如1个接收2个topic的Kafka InputDStream可以优化为2个InputDStream，各接收一个topic，然后在合并。</p></blockquote><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> numStreams = <span class="number">5</span></span><br><span class="line"><span class="keyword">val</span> kafkaStreams = (<span class="number">1</span> to numStreams).map&#123;</span><br><span class="line">    i =&gt; <span class="type">KafkaUtils</span>.createStream(...)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">val</span> unifiedStream = streamingContext.union(kafkaStreams)</span><br><span class="line">unifiedStream.print()</span><br></pre></td></tr></table></figure><ol start="2"><li><p>数据处理的并发度</p><blockquote><p>调整选项spark.default.parallelism</p></blockquote></li><li><p>task启动的额外开销</p><blockquote><p>如果task启动过于频繁（比如每秒50次），额外的开销可能非常高，甚至无法达到实时计算要求。</p></blockquote></li></ol><h3 id="设置合理批次间隔时间"><a href="#设置合理批次间隔时间" class="headerlink" title="设置合理批次间隔时间"></a>设置合理批次间隔时间</h3><blockquote><p>一般来说短时间间隔会导致更多的额外开销，以及无法完成的风险，所以前期采取相对保守的方法，将间隔设置为5~10秒。然后通过观察运行数据确保系统足够实时，每个间隔的实际计算时间远小于间隔时间，再逐渐缩短间隔时间。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;spark-streaming的状态更新&quot;&gt;&lt;a href=&quot;#spark-streaming的状态更新&quot; class=&quot;headerlink&quot; title=&quot;spark-streaming的状态更新&quot;&gt;&lt;/a&gt;spark-streaming的状态更新&lt;/h2&gt;&lt;
      
    
    </summary>
    
    
      <category term="spark" scheme="http://www.zzzhy.cn/categories/spark/"/>
    
    
      <category term="tuning" scheme="http://www.zzzhy.cn/tags/tuning/"/>
    
      <category term="scala" scheme="http://www.zzzhy.cn/tags/scala/"/>
    
      <category term="spark" scheme="http://www.zzzhy.cn/tags/spark/"/>
    
      <category term="spark streaming" scheme="http://www.zzzhy.cn/tags/spark-streaming/"/>
    
  </entry>
  
  <entry>
    <title>scala 日志处理实例</title>
    <link href="http://www.zzzhy.cn/2019/10/30/scala-log-handle/"/>
    <id>http://www.zzzhy.cn/2019/10/30/scala-log-handle/</id>
    <published>2019-10-29T16:24:31.000Z</published>
    <updated>2019-11-14T16:30:50.269Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>日志格式</p></blockquote><blockquote><p>100.97.15.241 - - [19/Aug/2016:11:05:47 +0800] “GET /view.php HTTP/1.0” 200 0 “<a href="http://www.gooogle.cn/search?q=hadoop&quot;" target="_blank" rel="noopener">http://www.gooogle.cn/search?q=hadoop&quot;</a> “Mozilla/5.0 (compatible;MSIE 10.0;Windows NT 6.2; Trident/6.0” “-“</p></blockquote><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 总PV页面浏览量    </span></span><br><span class="line">lines.count().print()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 各IP的PV，按PV倒序</span></span><br><span class="line"><span class="comment">//   空格分隔的第一个字段就是IP</span></span><br><span class="line">lines.map(line =&gt; &#123;(line.split(<span class="string">" "</span>)(<span class="number">0</span>), <span class="number">1</span>)&#125;).reduceByKey(_ + _).transform(rdd =&gt; &#123;</span><br><span class="line">  rdd.map(ip_pv =&gt; (ip_pv._2, ip_pv._1)).</span><br><span class="line">  sortByKey(<span class="literal">false</span>).</span><br><span class="line">  map(ip_pv =&gt; (ip_pv._2, ip_pv._1))</span><br><span class="line">&#125;).print()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 搜索引擎PV</span></span><br><span class="line"><span class="keyword">val</span> refer = lines.map(_.split(<span class="string">"\""</span>)(<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先输出搜索引擎和查询关键词，避免统计搜索关键词时重复计算</span></span><br><span class="line"><span class="comment">// 输出(host, query_keys)</span></span><br><span class="line"><span class="keyword">val</span> searchEnginInfo = refer.map(r =&gt; &#123;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">val</span> f = r.split('/')</span><br><span class="line">    <span class="comment">//搜索关键字的key</span></span><br><span class="line">    <span class="keyword">val</span> searchEngines = <span class="type">Map</span>(</span><br><span class="line">        <span class="string">"www.google.cn"</span> -&gt; <span class="string">"q"</span>,</span><br><span class="line">        <span class="string">"www.yahoo.com"</span> -&gt; <span class="string">"p"</span>,</span><br><span class="line">        <span class="string">"cn.bing.com"</span> -&gt; <span class="string">"q"</span>,</span><br><span class="line">        <span class="string">"www.baidu.com"</span> -&gt; <span class="string">"wd"</span>,</span><br><span class="line">        <span class="string">"www.sogou.com"</span> -&gt; <span class="string">"query"</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (f.length &gt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">val</span> host = f(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (searchEngines.contains(host)) &#123;</span><br><span class="line">            <span class="keyword">val</span> query = r.split('?')(<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> (query.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">val</span> arr_search_q = query.split('&amp;').filter(_.indexOf(searchEngines(host)+<span class="string">"="</span>) == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">if</span> (arr_search_q.length &gt; <span class="number">0</span>)</span><br><span class="line">                    (host, arr_search_q(<span class="number">0</span>).split('=')(<span class="number">1</span>))</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    (host, <span class="string">""</span>)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                (host, <span class="string">""</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            (<span class="string">""</span>, <span class="string">""</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        (<span class="string">""</span>, <span class="string">""</span>)</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出搜索引擎PV</span></span><br><span class="line">searchEnginInfo.filter(_._1.length &gt; <span class="number">0</span>).map(p =&gt; &#123;(p._1, <span class="number">1</span>)&#125;).reduceByKey(_ + _).print()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 关键词PV</span></span><br><span class="line">searchEnginInfo.filter(_._2.length &gt; <span class="number">0</span>).map(p =&gt; &#123;(p._2, <span class="number">1</span>)&#125;).reduceByKey(_ + _).print()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 终端类型PV</span></span><br><span class="line">lines.map(_.split(<span class="string">"\""</span>)(<span class="number">5</span>)).map(agent =&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> types = <span class="type">Seq</span>(<span class="string">"iPhone"</span>, <span class="string">"Android"</span>)</span><br><span class="line">    <span class="keyword">var</span> r = <span class="string">"Default"</span></span><br><span class="line">    <span class="keyword">for</span> (t &lt;- types) &#123;</span><br><span class="line">        <span class="keyword">if</span> (agent.indexOf(t) != <span class="number">-1</span>)</span><br><span class="line">            r = t</span><br><span class="line">    &#125;</span><br><span class="line">    (r, <span class="number">1</span>)</span><br><span class="line">&#125;).reduceByKey(_ + _).print()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 6. 各页面PV</span></span><br><span class="line">lines.map(line =&gt; &#123;(line.split(<span class="string">"\""</span>)(<span class="number">1</span>).split(<span class="string">" "</span>)(<span class="number">1</span>), <span class="number">1</span>)&#125;).reduceByKey(_ + _).print()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;日志格式&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;100.97.15.241 - - [19/Aug/2016:11:05:47 +0800] “GET /view.php HTTP/1.0” 200 0 “&lt;a hre
      
    
    </summary>
    
    
      <category term="scala" scheme="http://www.zzzhy.cn/categories/scala/"/>
    
    
      <category term="scala" scheme="http://www.zzzhy.cn/tags/scala/"/>
    
      <category term="spark" scheme="http://www.zzzhy.cn/tags/spark/"/>
    
      <category term="functional programming" scheme="http://www.zzzhy.cn/tags/functional-programming/"/>
    
  </entry>
  
  <entry>
    <title>scala 学习入门</title>
    <link href="http://www.zzzhy.cn/2019/10/30/scala-learning/"/>
    <id>http://www.zzzhy.cn/2019/10/30/scala-learning/</id>
    <published>2019-10-29T16:04:17.000Z</published>
    <updated>2019-11-14T16:30:16.471Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h2><blockquote><p>大部分都能隐式转换，Byte、Short需要显式指定</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val little : Byte = <span class="number">3</span></span><br><span class="line">val little:Short = <span class="number">3</span></span><br></pre></td></tr></table></figure><blockquote><p>char、String支持\转义</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val a = <span class="string">'a'</span>    <span class="comment">//char = 'a'</span></span><br><span class="line">val str = <span class="string">"hello \101"</span>      <span class="comment">//String=hello A</span></span><br></pre></td></tr></table></figure><blockquote><p>带小数点的默认为Double，以F结尾表示Float</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val pi = <span class="number">3.14</span>F</span><br><span class="line">val pi = <span class="number">3.14</span> <span class="comment">// double</span></span><br></pre></td></tr></table></figure><h2 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fun = <span class="function">(<span class="params">v : Int</span>) =&gt;</span> v + <span class="number">1</span>  <span class="comment">//匿名函数赋值给一个变量</span></span><br><span class="line">def addOne(v : Int) : Int = v + <span class="number">1</span>  <span class="comment">//非匿名函数</span></span><br></pre></td></tr></table></figure><h2 id="控制结构"><a href="#控制结构" class="headerlink" title="控制结构"></a>控制结构</h2><blockquote><p>if表达式</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val filename = </span><br><span class="line"><span class="keyword">if</span> (!args.isEmpty) args(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">else</span> <span class="string">"default.txt"</span></span><br></pre></td></tr></table></figure><blockquote><p>while循环</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//计算最大公约数</span></span><br><span class="line">def gcdLoop(x : Long,<span class="attr">y</span>: Long) : Long = &#123;</span><br><span class="line">    <span class="keyword">var</span> a = x</span><br><span class="line">    <span class="keyword">var</span> b = y</span><br><span class="line">    <span class="keyword">while</span> (a != <span class="number">0</span>)&#123;</span><br><span class="line">        val temp = a;</span><br><span class="line">        a = b % a;</span><br><span class="line">        b = temp</span><br><span class="line">    &#125;</span><br><span class="line">    b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>do…while</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> line = <span class="string">""</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    line = readLine()</span><br><span class="line">    println(<span class="string">"read:"</span>+line)</span><br><span class="line">&#125;<span class="keyword">while</span>(line != <span class="string">""</span>)</span><br></pre></td></tr></table></figure><blockquote><p>for表达式</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>( i &lt;- <span class="number">1</span> to <span class="number">4</span>)</span><br><span class="line">    println(<span class="string">"Iteration "</span>+ i)</span><br></pre></td></tr></table></figure><blockquote><p>try…catch</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">def g() : Int = &#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="number">1</span>/<span class="number">0</span></span><br><span class="line">    &#125;<span class="keyword">catch</span>&#123;</span><br><span class="line">        <span class="keyword">case</span> ex: <span class="function"><span class="params">ArithmeticException</span> =&gt;</span> &#123;</span><br><span class="line">            ex.toString</span><br><span class="line">            <span class="number">2</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> _ :<span class="function"><span class="params">Throwable</span> =&gt;</span> <span class="number">3</span></span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        println(<span class="string">"finally"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="基本数据结构"><a href="#基本数据结构" class="headerlink" title="基本数据结构"></a>基本数据结构</h2><blockquote><p>数组Array：可修改，通过括号()来引用</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val greeting = <span class="keyword">new</span> <span class="built_in">Array</span>[<span class="built_in">String</span>](<span class="number">2</span>)</span><br><span class="line">greeting(<span class="number">0</span>) = <span class="string">"hello"</span></span><br></pre></td></tr></table></figure><blockquote><p>列表List：只读</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val numbers = List(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">numbers(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><blockquote><p>元组Tuple：只读，与List类似，可以是不同元素,下标从1开始</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val hostPort = (<span class="string">"localhost"</span>,<span class="number">80</span>)</span><br><span class="line">hostPort._1</span><br><span class="line">hostPort._2</span><br></pre></td></tr></table></figure><blockquote><p>集合Set：只读，没有重复的元素</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Set</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>)</span><br></pre></td></tr></table></figure><blockquote><p>映射Map:</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">val m = <span class="built_in">Map</span>(<span class="number">1</span> -&gt; <span class="string">"one"</span>,<span class="number">2</span> -&gt; <span class="string">"two"</span>)</span><br><span class="line">m(<span class="number">2</span>)</span><br><span class="line"><span class="comment">//创建可写版本</span></span><br><span class="line">val m = scala.collection.mutable.Map[Int,<span class="built_in">String</span>](<span class="number">1</span> -&gt; <span class="string">"one"</span>,<span class="number">2</span> -&gt; <span class="string">"two"</span>)</span><br><span class="line">m += (<span class="number">3</span> -&gt; <span class="string">"three"</span>)</span><br><span class="line">m(<span class="number">4</span>)=<span class="string">"four"</span></span><br><span class="line">m -= <span class="number">2</span></span><br></pre></td></tr></table></figure><h2 id="定义class"><a href="#定义class" class="headerlink" title="定义class"></a>定义class</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Hello( _a : Int) &#123;</span><br><span class="line">    private val a = _a;</span><br><span class="line">    println(<span class="string">"initializing...("</span> + _a + “） ”);</span><br><span class="line">    def add( b : Int) : Int = a + b;</span><br><span class="line">    def <span class="keyword">this</span>() = <span class="keyword">this</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class Hello2(a : Int) extends Hello(a) &#123;</span><br><span class="line">    def add(b : Int, <span class="attr">c</span> : Int) : Int = a + b+ c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="单实例对象"><a href="#单实例对象" class="headerlink" title="单实例对象"></a>单实例对象</h2><blockquote><p>scala 不支持static变量、成员，但提供了单例对象，用object来定义</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">object Timer &#123;</span><br><span class="line">    <span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line">    def currentCount() : Long = &#123;</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        count</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Timer.currentCount()</span><br></pre></td></tr></table></figure><blockquote><p>单例对象可以和类具有相同的名字，放在同一个源文件，可以相互访问彼此的private方法和变量。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Bar(foo : String)</span><br><span class="line">object Bar&#123;</span><br><span class="line">    def apply(foo : <span class="built_in">String</span>) = <span class="keyword">new</span> Bar(foo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(x:Int) =&gt; x+<span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> incr = <span class="function">(<span class="params">x:Int</span>) =&gt;</span> x+<span class="number">1</span></span><br><span class="line">incr(<span class="number">10</span>)</span><br></pre></td></tr></table></figure><h2 id="匿名函数作为参数"><a href="#匿名函数作为参数" class="headerlink" title="匿名函数作为参数"></a>匿名函数作为参数</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">val someNumbers = List(<span class="number">1</span>,<span class="number">3</span>,<span class="number">-2</span>,<span class="number">0</span>)</span><br><span class="line">someNumbers.filter( <span class="function"><span class="params">x</span> =&gt;</span> x &gt; <span class="number">0</span> )</span><br><span class="line"><span class="comment">//如果匿名函数的参数只被使用一次，可以直接写函数体，用_代替一个参数</span></span><br><span class="line">someNumbers.filter(_ &gt; <span class="number">0</span>)</span><br></pre></td></tr></table></figure><h2 id="函数嵌套"><a href="#函数嵌套" class="headerlink" title="函数嵌套"></a>函数嵌套</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scala.io.Source</span><br><span class="line">def processFile(filename : <span class="built_in">String</span>)&#123;</span><br><span class="line">    def processLine(line : <span class="built_in">String</span>)&#123;</span><br><span class="line">        println(line)</span><br><span class="line">    &#125;</span><br><span class="line">    Source.fromFile(filename).getLines.foreach(processLine);</span><br><span class="line">&#125;</span><br><span class="line">processFile(<span class="string">"t.scala"</span>)</span><br></pre></td></tr></table></figure><h2 id="部分应用函数"><a href="#部分应用函数" class="headerlink" title="部分应用函数"></a>部分应用函数</h2><blockquote><p>函数的参数可以分步提供</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def adder(m : Int,<span class="attr">n</span> : Int, <span class="attr">z</span> : Int) : Int = m + n + z</span><br><span class="line">val adder2 = adder(<span class="number">2</span>,<span class="attr">_</span>:Int,<span class="attr">_</span>:Int) <span class="comment">//部分应用函数，只输入参数2，用_代替没有准备好的另一个参数</span></span><br><span class="line">val adder3 = add2(<span class="number">3</span>,<span class="attr">_</span>:Int)</span><br><span class="line">adder3(<span class="number">4</span>)  <span class="comment">//9</span></span><br></pre></td></tr></table></figure><h2 id="柯里化函数currying"><a href="#柯里化函数currying" class="headerlink" title="柯里化函数currying"></a>柯里化函数currying</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//非柯里化函数</span></span><br><span class="line">def plainSum(x : Int,<span class="attr">y</span> : Int) = x + y;</span><br><span class="line">plainSum(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"><span class="comment">//柯里化</span></span><br><span class="line">def curriedSum(x:Int)(y:Int) = x + y</span><br><span class="line"><span class="comment">//可以一次输入两个参数来调用</span></span><br><span class="line">curriedSum(<span class="number">1</span>)(<span class="number">2</span>)</span><br><span class="line">val onePlus = curriedSum(<span class="number">1</span>)_  <span class="comment">//使用了部分应用函数符号_</span></span><br><span class="line">onePlus(<span class="number">2</span>)</span><br><span class="line">val twoPlus = curriedSum(<span class="number">2</span>)_</span><br><span class="line">twoPlus(<span class="number">3</span>)  <span class="comment">//5</span></span><br></pre></td></tr></table></figure><h2 id="包"><a href="#包" class="headerlink" title="包"></a>包</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">package org.scala.example</span><br><span class="line">object Color&#123;</span><br><span class="line">    val BLUE = <span class="string">"Blue"</span></span><br><span class="line">    val Green = <span class="string">"Green"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">times match&#123;</span><br><span class="line">   <span class="keyword">case</span> <span class="number">1</span> =&gt; <span class="string">"one"</span></span><br><span class="line">   <span class="keyword">case</span> <span class="number">2</span> =&gt; <span class="string">"two"</span></span><br><span class="line">   <span class="keyword">case</span> <span class="function"><span class="params">_</span> =&gt;</span> <span class="string">"some other"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对象匹配</span></span><br><span class="line">def bigger(o : Any) : Any = &#123;</span><br><span class="line">   o match &#123;</span><br><span class="line">       <span class="keyword">case</span> i : Int <span class="keyword">if</span> i &gt; <span class="number">0</span> =&gt; i - <span class="number">1</span></span><br><span class="line">       <span class="keyword">case</span> i : <span class="function"><span class="params">Int</span> =&gt;</span> i + <span class="number">1</span></span><br><span class="line">       <span class="keyword">case</span> d: Double <span class="keyword">if</span> d &gt; <span class="number">0.0</span> =&gt; d - <span class="number">0.1</span></span><br><span class="line">       <span class="keyword">case</span> d: <span class="function"><span class="params">Double</span> =&gt;</span> d + <span class="number">0.1</span></span><br><span class="line">       <span class="keyword">case</span> text:<span class="function"><span class="params">String</span> =&gt;</span> text + <span class="string">"s"</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">val v42 = <span class="number">42</span></span><br><span class="line"><span class="comment">// print Not 42</span></span><br><span class="line">Some(<span class="number">3</span>) match &#123;</span><br><span class="line">   <span class="keyword">case</span> Some(<span class="string">`v42`</span>) =&gt; println(<span class="string">"42"</span>)</span><br><span class="line">   <span class="keyword">case</span> <span class="function"><span class="params">_</span> =&gt;</span> println(<span class="string">"Not 42"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="scala应用程序"><a href="#scala应用程序" class="headerlink" title="scala应用程序"></a>scala应用程序</h2><blockquote><p>入口：单实例对象，内部必须有一个main方法，main有且仅有一个Array[String]的参数，并且返回Unit</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Hello.scala</span></span><br><span class="line">object Hello&#123;</span><br><span class="line">    def main(args : <span class="built_in">Array</span>[<span class="built_in">String</span>]) &#123;</span><br><span class="line">        <span class="keyword">for</span> (arg &lt;- args)</span><br><span class="line">            println(<span class="string">"hello "</span> + arg)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行：</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; scala Hello scala spark</span><br><span class="line">//<span class="built_in">print</span></span><br><span class="line">hello scala</span><br><span class="line">hello spark</span><br></pre></td></tr></table></figure><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">var</span> more =<span class="number">1</span></span><br><span class="line">more: Int = <span class="number">1</span></span><br><span class="line">scala&gt; val addMore = <span class="function">(<span class="params">x:Int</span>) =&gt;</span> x + more</span><br><span class="line">addMore: <span class="function"><span class="params">Int</span> =&gt;</span> Int = <span class="xml"><span class="tag">&lt;<span class="name">function1</span>&gt;</span></span></span><br><span class="line"><span class="xml">scala&gt; addMore (100)</span></span><br><span class="line"><span class="xml">res1: Int = 101</span></span><br><span class="line"><span class="xml">//addMore为闭包，引用了外部变量more。当这个自由变量发生变化时，Scala 的闭包能够捕获到这个变化，因此 Scala 的闭包捕获的是**变量本身**而不是当时变量的值。</span></span><br><span class="line"><span class="xml">scala&gt; more =  9999</span></span><br><span class="line"><span class="xml">more: Int = 9999</span></span><br><span class="line"><span class="xml">scala&gt; addMore ( 10)</span></span><br><span class="line"><span class="xml">res2: Int = 10009</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">如果变量在闭包在发生变化，也会反映到函数外面定义的闭包的值。比如：</span></span><br><span class="line"><span class="xml">scala&gt; val someNumbers = List ( -11, -10, -5, 0, 5, 10)</span></span><br><span class="line"><span class="xml">someNumbers: List[Int] = List(-11, -10, -5, 0, 5, 10)</span></span><br><span class="line"><span class="xml">scala&gt; var sum =0</span></span><br><span class="line"><span class="xml">sum: Int = 0</span></span><br><span class="line"><span class="xml">scala&gt; someNumbers.foreach ( sum += _)</span></span><br><span class="line"><span class="xml">scala&gt; sum</span></span><br><span class="line"><span class="xml">res4: Int = -11</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;基本类型&quot;&gt;&lt;a href=&quot;#基本类型&quot; class=&quot;headerlink&quot; title=&quot;基本类型&quot;&gt;&lt;/a&gt;基本类型&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;大部分都能隐式转换，Byte、Short需要显式指定&lt;/p&gt;
&lt;/blockquote&gt;
&lt;fig
      
    
    </summary>
    
    
      <category term="scala" scheme="http://www.zzzhy.cn/categories/scala/"/>
    
    
      <category term="scala" scheme="http://www.zzzhy.cn/tags/scala/"/>
    
  </entry>
  
</feed>
